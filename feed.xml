<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https:///williampolicy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https:///williampolicy.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-28T12:44:12+00:00</updated><id>https:///williampolicy.github.io/feed.xml</id><title type="html">blank</title><subtitle>I would want to make a set [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/" rel="alternate" type="text/html" title="" /><published>2023-06-28T12:44:12+00:00</published><updated>2023-06-28T12:44:12+00:00</updated><id>https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/"><![CDATA[<p>Today we explored how to integrate OpenAI’s GPT-3 into an iOS application using Swift. This process mainly involves setting up API requests, handling response data, and testing in a simulator. In this process, we also used Git for version control and error tracking.</p>

<h2 id="setting-up-api-requests">Setting Up API Requests</h2>
<p>We first created a function in Swift to set up the API request. This function takes an input prompt and sends it to the OpenAI API to generate GPT-3 output. We used the <code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code> function to send the request and <code class="language-plaintext highlighter-rouge">JSONSerialization</code> to convert the returned data into a JSON format we can handle.</p>

<h2 id="handling-api-responses">Handling API Responses</h2>
<p>When handling the API response, we focused on the <code class="language-plaintext highlighter-rouge">choices</code> field, which contains the text generated by GPT-3. We took the first choice from this field and returned it as the result of the function.</p>

<h2 id="testing-in-simulator">Testing in Simulator</h2>
<p>Next, we tested in the iOS simulator. We used the command-line tool <code class="language-plaintext highlighter-rouge">xcrun simctl</code> to manage the simulator and the <code class="language-plaintext highlighter-rouge">xcrun simctl launch</code> command to launch our application. When the application runs in the simulator, we can see all the output of the print() statements in the console, including any error messages, which is very useful for debugging.</p>

<h2 id="using-git-for-version-control-and-error-tracking">Using Git for Version Control and Error Tracking</h2>
<p>When we encountered errors, we used Git for error tracking.</p>

<hr />

<p><strong>layout:</strong> post</p>

<p><strong>title:</strong> “集成GPT-3到iOS应用中：使用Swift进行OpenAI API调用”</p>

<p><strong>date:</strong> 2023-06-19</p>

<p><strong>categories:</strong> [OpenAI, GPT-3, iOS, Swift, App Development]</p>

<hr />

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<h2 id="创建api请求">创建API请求</h2>
<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用<code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code>函数发送请求，并使用<code class="language-plaintext highlighter-rouge">JSONSerialization</code>将返回的数据转换为我们可以处理的JSON格式。</p>

<h2 id="处理api响应">处理API响应</h2>
<p>在处理API响应时，我们主要关注的是<code class="language-plaintext highlighter-rouge">choices</code>字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<h2 id="在模拟器中进行测试">在模拟器中进行测试</h2>
<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具<code class="language-plaintext highlighter-rouge">xcrun simctl</code>来管理模拟器，并使用<code class="language-plaintext highlighter-rouge">xcrun simctl launch</code>命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用URLSession.shared.dataTask(with:completionHandler:)函数发送请求，并使用JSONSerialization将返回的数据转换为我们可以处理的JSON格式。</p>

<p>在处理API响应时，我们主要关注的是choices字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具xcrun simctl来管理模拟器，并使用xcrun simctl launch命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>当我们遇到错误时，我们使用Git进行错误跟踪。我们首先使用git diff查看自上次提交以来我们做了哪些改动，然后使用git log查看提交历史，找出可能导致错误的提交。一旦找到错误，我们就可以使用git revert来撤销这个提交，然后再进行修复。</p>

<p>当我们的应用正常运行并能够产生期望的输出时，我们使用Git来保存这个版本。我们首先使用git add .将所有改动添加到暂存区，然后使用git commit -m提交这些改动，并添加一个描述性的消息。最后，我们使用git tag添加一个标签来标记这个版本，然后使用git push将这个标签推送到远程仓库。</p>

<p>今天的工作中，我们学到了很多关于如何集成OpenAI的GPT-3到iOS应用中，如何在模拟器中进行测试，以及如何使用Git进行版本控制和错误跟踪的知识。我们还通过实际的操作，熟悉了这些工具和技术的应用。希望这个经验对你的工作也有所帮</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/" rel="alternate" type="text/html" title="" /><published>2023-06-28T00:00:00+00:00</published><updated>2023-06-28T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/"><![CDATA[<p>#Quantum Physics: The Schrödinger Equation and the Delta Function Potential</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">title</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Quantum</span><span class="nv"> </span><span class="s">Physics:</span><span class="nv"> </span><span class="s">The</span><span class="nv"> </span><span class="s">Schrödinger</span><span class="nv"> </span><span class="s">Equation</span><span class="nv"> </span><span class="s">and</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">Delta</span><span class="nv"> </span><span class="s">Function</span><span class="nv"> </span><span class="s">Potential"</span>
<span class="na">date</span><span class="pi">:</span> <span class="s">2023-06-30</span>
<span class="nn">---</span>

Quantum physics provides a fascinating perspective on the behaviors of microscopic particles. At the heart of quantum physics lies the Schrödinger equation, a fundamental equation governing these behaviors. In this blog post, we will delve deeper into a simplified version of the Schrödinger equation in one-dimensional space, specifically focusing on the implications of a delta function potential well or barrier on a particle's state.

The time-independent Schrödinger equation in one dimension is typically written as:

<span class="p">```</span><span class="nl">markdown
</span>-<span class="se">\f</span>rac{<span class="se">\h</span>bar^2}{2m}<span class="se">\f</span>rac{d^2<span class="se">\p</span>si(x)}{dx^2} + V(x)<span class="se">\p</span>si(x) = E<span class="se">\p</span>si(x)
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">\hbar</code> is the reduced Planck constant, <code class="language-plaintext highlighter-rouge">m</code> is the particle’s mass, <code class="language-plaintext highlighter-rouge">\psi(x)</code> is the wave function describing the particle’s state at position <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">V(x)</code> is the potential energy function, and <code class="language-plaintext highlighter-rouge">E</code> is the total energy of the system.</p>

<p>In scenarios where the particle experiences a sudden change in potential, such as an energy barrier or well, the potential energy function <code class="language-plaintext highlighter-rouge">V(x)</code> is often modeled using a delta function. In this context, <code class="language-plaintext highlighter-rouge">V(x)</code> is defined as <code class="language-plaintext highlighter-rouge">V(x) = V_0\delta(x)</code>, where <code class="language-plaintext highlighter-rouge">V_0</code> is the strength of the potential.</p>

<p>In the presence of a delta function potential, the original Schrödinger equation splits into two independent equations describing the particle’s behavior for <code class="language-plaintext highlighter-rouge">x&lt;0</code> and <code class="language-plaintext highlighter-rouge">x&gt;0</code>:</p>

<p>For <code class="language-plaintext highlighter-rouge">x&lt;0</code>:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="se">\f</span>rac{<span class="se">\h</span>bar^2}{2m}<span class="se">\f</span>rac{d^2<span class="se">\p</span>si(x)}{dx^2} = E<span class="se">\p</span>si(x)
</code></pre></div></div>

<p>For <code class="language-plaintext highlighter-rouge">x&gt;0</code>:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="se">\f</span>rac{<span class="se">\h</span>bar^2}{2m}<span class="se">\f</span>rac{d^2<span class="se">\p</span>si(x)}{dx^2} = E<span class="se">\p</span>si(x)
</code></pre></div></div>

<p>Even though the Schrödinger equation maintains the same form for <code class="language-plaintext highlighter-rouge">x&lt;0</code> and <code class="language-plaintext highlighter-rouge">x&gt;0</code>, the introduction of a delta function potential at <code class="language-plaintext highlighter-rouge">x=0</code> leads to a discontinuity in the first derivative of the wave function. The discontinuity can be described by:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="se">\f</span>rac{<span class="se">\h</span>bar^2}{2m}(<span class="se">\p</span>si'(0^+)-<span class="se">\p</span>si'(0^-)) = V_0<span class="se">\p</span>si(0)
</code></pre></div></div>

<p>This example illustrates the use of a delta function to simulate a sudden potential in the context of the Schrödinger equation. By solving the aforementioned equations, we can gain insights into the quantum mechanical behavior of particles in the presence of abrupt potential changes.</p>

<p>Through this deep-dive into the Schrödinger equation and the implications of a delta function potential, we hope to shed some light on the intricacies of quantum physics and inspire further exploration into this fascinating field.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>


对不起给你带来的困扰。我理解你需要的是一个完整的`.md`文件格式的博客文章。这里是整个文章的`.md`文件格式：

```markdown
# Quantum Physics: The Schrödinger Equation and the Delta Function Potential

Quantum physics provides a fascinating perspective on the behaviors of microscopic particles. At the heart of quantum physics lies the Schrödinger equation, a fundamental equation governing these behaviors. In this blog post, we will delve deeper into a simplified version of the Schrödinger equation in one-dimensional space, specifically focusing on the implications of a delta function potential well or barrier on a particle's state.

The time-independent Schrödinger equation in one dimension is typically written as:

```latex
-\frac{\hbar^2}{2m}\frac{d^2\psi(x)}{dx^2} + V(x)\psi(x) = E\psi(x)
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">\hbar</code> is the reduced Planck constant, <code class="language-plaintext highlighter-rouge">m</code> is the particle’s mass, <code class="language-plaintext highlighter-rouge">\psi(x)</code> is the wave function describing the particle’s state at position <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">V(x)</code> is the potential energy function, and <code class="language-plaintext highlighter-rouge">E</code> is the total energy of the system.</p>

<p>In scenarios where the particle experiences a sudden change in potential, such as an energy barrier or well, the potential energy function <code class="language-plaintext highlighter-rouge">V(x)</code> is often modeled using a delta function. In this context, <code class="language-plaintext highlighter-rouge">V(x)</code> is defined as <code class="language-plaintext highlighter-rouge">V(x) = V_0\delta(x)</code>, where <code class="language-plaintext highlighter-rouge">V_0</code> is the strength of the potential.</p>

<p>In the presence of a delta function potential, the original Schrödinger equation splits into two independent equations describing the particle’s behavior for <code class="language-plaintext highlighter-rouge">x&lt;0</code> and <code class="language-plaintext highlighter-rouge">x&gt;0</code>:</p>

<p>For <code class="language-plaintext highlighter-rouge">x&lt;0</code>:</p>

<div class="language-latex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="k">\frac</span><span class="p">{</span><span class="k">\hbar</span><span class="p">^</span>2<span class="p">}{</span>2m<span class="p">}</span><span class="k">\frac</span><span class="p">{</span>d<span class="p">^</span>2<span class="k">\psi</span>(x)<span class="p">}{</span>dx<span class="p">^</span>2<span class="p">}</span> = E<span class="k">\psi</span>(x)
</code></pre></div></div>

<p>For <code class="language-plaintext highlighter-rouge">x&gt;0</code>:</p>

<div class="language-latex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-<span class="k">\frac</span><span class="p">{</span><span class="k">\hbar</span><span class="p">^</span>2<span class="p">}{</span>2m<span class="p">}</span><span class="k">\frac</span><span class="p">{</span>d<span class="p">^</span>2<span class="k">\psi</span>(x)<span class="p">}{</span>dx<span class="p">^</span>2<span class="p">}</span> = E<span class="k">\psi</span>(x)
</code></pre></div></div>

<p>Even though the Schrödinger equation maintains the same form for <code class="language-plaintext highlighter-rouge">x&lt;0</code> and <code class="language-plaintext highlighter-rouge">x&gt;0</code>, the introduction of a delta function potential at <code class="language-plaintext highlighter-rouge">x=0</code> leads to a discontinuity in the first derivative of the wave function. The discontinuity can be described by:</p>

<div class="language-latex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">\frac</span><span class="p">{</span><span class="k">\hbar</span><span class="p">^</span>2<span class="p">}{</span>2m<span class="p">}</span>(<span class="k">\psi</span>'(0<span class="p">^</span>+)-<span class="k">\psi</span>'(0<span class="p">^</span>-)) = V<span class="p">_</span>0<span class="k">\psi</span>(0)
</code></pre></div></div>

<p>This example illustrates the use of a delta function to simulate a sudden potential in the context of the Schrödinger equation. By solving the aforementioned equations, we can gain insights into the quantum mechanical behavior of particles in the presence of abrupt potential changes.</p>

<p>Through this deep-dive into the Schrödinger equation and the implications of a delta function potential, we hope to shed some light on the intricacies of quantum physics and inspire further exploration into this fascinating field.
```</p>]]></content><author><name></name></author><category term="x" /><category term="function" /><category term="potential" /><category term="psi" /><category term="equation" /><summary type="html"><![CDATA[#Quantum Physics: The Schrödinger Equation and the Delta Function Potential]]></summary></entry><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/" rel="alternate" type="text/html" title="" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/"><![CDATA[<h1 id="dirac-delta-function-and-approaching-truth">Dirac Delta Function and Approaching Truth</h1>

<h2 id="dirac-delta-function-a-tool-for-first-order-approximation">Dirac Delta Function: A Tool for First-Order Approximation</h2>

<p>The Dirac delta function is a crucial tool we utilize to approach complex systems. This function is particularly significant in the microscopic world, as it can depict sudden changes and transitions, acting as a connector between continuous and discrete sampling. The Dirac delta function bridges high-dimensional and low-dimensional spaces, revealing the relationships between the two. Thus, we can perceive discrete phenomena, which are frequently observed during the quantization process.</p>

<p>Although the Dirac delta function is an idealized tool, its properties of infinity and infinitesimal provide a new perspective for understanding phenomena. However, this first-order approximation may face difficulties in practical applications and numerical simulations.</p>

<h2 id="second-order-approximation-adapting-to-reality">Second-Order Approximation: Adapting to Reality</h2>

<p>Faced with the challenges of practical applications, we often need to adopt more practical second-order approximation methods, such as using Gaussian functions or Cauchy distribution functions to simulate the Dirac delta function. While this practice may sacrifice some degree of truth purity, it enables more convenient numerical simulation and theoretical analysis.</p>

<p>This second-order approximation method allows us to see the underlying structure more clearly and facilitates practical operations. With specific numerical simulations and functions, we can quantify infinity and infinitesimal, and carry out grading and hierarchical treatment of them, which is of vital significance for our understanding and simulation of real-world problems.</p>

<h2 id="grading-issue-of-infinity-and-infinitesimal">Grading Issue of Infinity and Infinitesimal</h2>

<p>In this process, we noticed that infinity and infinitesimal are not simple concepts. Infinity and infinitesimal actually exist at different levels, which is determined by comparing their behaviors. This treatment allows us to grade and hierarchically process infinity and infinitesimal.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Whether it’s the first-order approximation of the Dirac delta function or the more practical second-order approximation method, we are approaching the complex, profound real world in our own ways. In the pursuit of scientific truth, we often need to strike a balance between theoretical rigor and practicality. That’s the essence of science.</p>

<p>#狄拉克函数与逼近真相</p>

<p>##狄拉克函数：一级逼近的工具
狄拉克函数是我们用来逼近复杂系统的一个重要工具。这个函数在微观世界中尤其重要，因为它可以描述突变和跃变，是连续和离散采样的连通器。狄拉克函数把高维度空间和低维度空间连通起来，揭示了这两个空间之间的关系。因此，我们可以看到离散的现象，这是我们在量子化过程中经常会看到的。</p>

<p>尽管狄拉克函数是一种理想化的工具，其无穷大和无穷小的性质为我们理解现象提供了新的视角，但在实际的应用和数值模拟中，这种一级逼近可能存在困难。</p>

<p>##二级逼近：适应现实的方法
面对实际应用的挑战，我们往往需要采用更加实用的二级逼近方法，例如使用高斯函数或Cauchy分布函数等来模拟狄拉克函数。这种做法虽然会牺牲一部分真相纯度，但却能使我们能够更方便地进行数值模拟和理论分析。</p>

<p>这种二级逼近方法让我们可以更加清楚地看到背后的结构，也方便我们进行实际操作。通过具体的数值模拟和函数，我们能够量化无穷大和无穷小，对它们进行分级和层次化的处理，这对我们理解和模拟现实问题有重要的意义。</p>

<p>##无穷大和无穷小的分级问题
在这个过程中，我们注意到无穷大和无穷小并非简单的概念。无穷大和无穷小实际上存在不同的级别，这是通过比较它们的行为来确定的。这样的处理方式，使得我们能够对无穷大和无穷小进行分级和分层次的处理。</p>

<p>##总结
无论是狄拉克函数的一级逼近，还是更实用的二级逼近方法，我们都在用自己的方式去逼近这个复杂、深奥的真实世界。在追求科学真相的过程中，我们经常需要在理论的严谨性和实用性之间做出权衡，这就是科学的本质。</p>]]></content><author><name></name></author><category term="function" /><category term="approximation" /><category term="delta" /><category term="delta function" /><category term="dirac" /><summary type="html"><![CDATA[Dirac Delta Function and Approaching Truth]]></summary></entry><entry><title type="html">Designing a Comprehensive Database for Dairy Products Sales Analysis</title><link href="https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis/" rel="alternate" type="text/html" title="Designing a Comprehensive Database for Dairy Products Sales Analysis" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis/"><![CDATA[<p>#Designing a Comprehensive Database for Dairy Products Sales Analysis</p>

<h2 id="background">Background</h2>

<p>The dairy industry is a complex sector, and having a proper database design is crucial for understanding sales patterns, supply chain management, and consumer behavior. This blog post aims to present a comprehensive design for a dairy products sales database that takes into account various factors influencing the industry, including consumption patterns of families, detailed dairy product information, supplier data, discount events, holidays, and extreme weather conditions.</p>

<h2 id="requirements">Requirements</h2>

<p>The objective was to design a database for a hypothetical dairy company, aiming to assist in understanding sales trends, consumer behaviors, and supply chain dynamics. The database needed to be capable of answering critical questions like:</p>

<ul>
  <li>How do family consumption patterns change during holidays or extreme weather conditions?</li>
  <li>What are the sales trends for different dairy products?</li>
  <li>How do supplier flexibility and discount events impact sales and inventory?</li>
  <li>How does the timing of holidays influence sales?</li>
</ul>

<h2 id="database-design">Database Design</h2>

<p>To answer these questions, we conceptualized a relational database model with six primary tables and two summary tables.</p>

<h3 id="primary-tables">Primary Tables</h3>

<p><strong>T1_Family_Consumption</strong>: Each row represents a unique dairy product purchased by a specific family on a certain date, and fields include Family_ID, Product_ID, Date, Price_at_Purchase, Quantity, Is_Holiday, Is_Extreme_Weather, and Is_Discounted.</p>

<p><strong>T2_Dairy_Products</strong>: Each row represents daily information about a dairy product, and fields include Product_ID, Date, Price, Inventory, and Sales.</p>

<p><strong>T3_Suppliers</strong>: Each row represents supplier information for a specific dairy product, and fields include Supplier_ID, Product_ID, Supply_Price, and Flexibility.</p>

<p><strong>T4_Discounts</strong>: Each row signifies whether a specific product has a discount during a specific time period, and fields include Discount_ID, Product_ID, Start_Date, End_Date, and Discount_Rate.</p>

<p><strong>T5_Holidays</strong>: Each row denotes whether a particular date is a holiday, and fields include Date and Is_Holiday.</p>

<p><strong>T6_Extreme_Weather</strong>: Each row indicates whether there’s extreme weather on a specific date, and fields include Date and Is_Extreme.</p>

<h3 id="summary-tables">Summary Tables</h3>

<p><strong>T1S_Transactions_Summary</strong>: Each row represents aggregate information about a transaction, and fields include Transaction_ID, Date, Family_ID, Total_Quantity, and Total_Price.</p>

<p><strong>T4S_Discount_Events_Summary</strong>: Each row signifies overall information about a discount event, and fields include Discount_ID, Start_Date, End_Date, and Total_Products_Discounted.</p>

<h2 id="relationships">Relationships</h2>

<p>The primary tables are interconnected through specific fields such as Family_ID, Product_ID, Date, Transaction_ID, and Discount_ID. These connections allow for a comprehensive picture of the dairy sales cycle. The summary tables link to the primary tables through the Transaction_ID and Discount_ID fields, enabling an aggregated view of transaction and discount event details.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This database design offers a comprehensive approach to understand the sales dynamics in the dairy industry. By amalgamating various factors influencing sales, this design provides valuable insights that can assist in decision-making for the dairy company.</p>

<p><strong>标题：为奶制品销售分析设计全面的数据库</strong></p>

<h2 id="背景">背景</h2>

<p>奶制品行业是一个复杂的领域，拥有合适的数据库设计对于理解销售模式、供应链管理和消费者行为至关重要。本博客旨在为奶制品销售数据库提供一个全面的设计，考虑了影响行业的各种因素，包括家庭消费模式、详细的奶制品信息、供应商数据、折扣事件、节假日和极端天气条件。</p>

<h2 id="需求">需求</h2>

<p>我们的目标是为一家假想的奶制品公司设计数据库，旨在帮助理解销售趋势、消费者行为和供应链动态。该数据库需要能够回答关键问题，例如：</p>

<ul>
  <li>家庭消费模式在节假日或极端天气条件下如何改变？</li>
  <li>不同奶制品的销售趋势是什么？</li>
  <li>供应商灵活性和折扣活动如何影响销售和库存？</li>
  <li>节假日的时间如何影响销售？</li>
</ul>

<h2 id="数据库设计">数据库设计</h2>

<p>为了回答这些问题，我们构思了一个包含六个主要表和两个汇总表的关系型数据库模型。</p>

<h3 id="主要表格">主要表格</h3>

<p><strong>T1_家庭消费（Family_Consumption）</strong>：每一行代表特定家庭在特定日期购买的独特的奶制品，字段包括：Family_ID、Product_ID、Date、Price_at_Purchase、Quantity、Is_Holiday、Is_Extreme_Weather和Is_Discounted。</p>

<p><strong>T2_奶制品（Dairy_Products）</strong>：每一行代表关于奶制品的每日信息，字段包括：Product_ID、Date、Price、Inventory和Sales。</p>

<p><strong>T3_供应商（Suppliers）</strong>：每一行代表特定奶制品的供应商信息，字段包括：Supplier_ID、Product_ID、Supply_Price和Flexibility。</p>

<p><strong>T4_折扣（Discounts）</strong>：每一行表示特定产品在特定时间段是否有折扣，字段包括：Discount_ID、Product_ID、Start_Date、End_Date和Discount_Rate。</p>

<p><strong>T5_节假日（Holidays）</strong>：每一行表示特定日期是否为节假日，字段包括：Date和Is_Holiday。</p>

<p><strong>T6_极端天气（Extreme_Weather）</strong>：每一行表示特定日期是否有极端天气，字段包括：Date和Is_Extreme。</p>

<h3 id="汇总表">汇总表</h3>

<p><strong>T1S_交易汇总（Transactions_Summary）</strong>：每一行代表关于交易的汇总信息，字段包括：Transaction_ID、Date、Family_ID、Total_Quantity和Total_Price。</p>

<p>**T4S_折扣事件汇总（Discount_Events_Summary）</p>

<p>**：每一行表示关于折扣事件的总体信息，字段包括：Discount_ID、Start_Date、End_Date和Total_Products_Discounted。</p>

<h2 id="关系">关系</h2>

<p>主要表格通过特定字段如Family_ID、Product_ID、Date、Transaction_ID和Discount_ID相互连接。这些连接为奶制品销售周期提供了全面的画像。汇总表通过Transaction_ID和Discount_ID字段链接到主要表，使得可以对交易和折扣事件细节进行汇总查看。</p>

<h2 id="结论">结论</h2>

<p>此数据库设计提供了一个全面的方法来理解奶制品行业的销售动态。通过结合影响销售的各种因素，该设计提供了可以帮助奶制品公司决策的宝贵见解。</p>]]></content><author><name></name></author><category term="id" /><category term="date" /><category term="discount" /><category term="product" /><category term="dairy" /><summary type="html"><![CDATA[#Designing a Comprehensive Database for Dairy Products Sales Analysis]]></summary></entry><entry><title type="html">Dirac Delta Function and Approaching Truth</title><link href="https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth/" rel="alternate" type="text/html" title="Dirac Delta Function and Approaching Truth" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth/"><![CDATA[<h1 id="dirac-delta-function-and-approaching-truth">Dirac Delta Function and Approaching Truth</h1>

<h2 id="dirac-delta-function-a-tool-for-first-order-approximation">Dirac Delta Function: A Tool for First-Order Approximation</h2>

<p>The Dirac delta function is a crucial tool we utilize to approach complex systems. This function is particularly significant in the microscopic world, as it can depict sudden changes and transitions, acting as a connector between continuous and discrete sampling. The Dirac delta function bridges high-dimensional and low-dimensional spaces, revealing the relationships between the two. Thus, we can perceive discrete phenomena, which are frequently observed during the quantization process.</p>

<p>Although the Dirac delta function is an idealized tool, its properties of infinity and infinitesimal provide a new perspective for understanding phenomena. However, this first-order approximation may face difficulties in practical applications and numerical simulations.</p>

<h2 id="second-order-approximation-adapting-to-reality">Second-Order Approximation: Adapting to Reality</h2>

<p>Faced with the challenges of practical applications, we often need to adopt more practical second-order approximation methods, such as using Gaussian functions or Cauchy distribution functions to simulate the Dirac delta function. While this practice may sacrifice some degree of truth purity, it enables more convenient numerical simulation and theoretical analysis.</p>

<p>This second-order approximation method allows us to see the underlying structure more clearly and facilitates practical operations. With specific numerical simulations and functions, we can quantify infinity and infinitesimal, and carry out grading and hierarchical treatment of them, which is of vital significance for our understanding and simulation of real-world problems.</p>

<h2 id="grading-issue-of-infinity-and-infinitesimal">Grading Issue of Infinity and Infinitesimal</h2>

<p>In this process, we noticed that infinity and infinitesimal are not simple concepts. Infinity and infinitesimal actually exist at different levels, which is determined by comparing their behaviors. This treatment allows us to grade and hierarchically process infinity and infinitesimal.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Whether it’s the first-order approximation of the Dirac delta function or the more practical second-order approximation method, we are approaching the complex, profound real world in our own ways. In the pursuit of scientific truth, we often need to strike a balance between theoretical rigor and practicality. That’s the essence of science.</p>

<p>#狄拉克函数与逼近真相</p>

<p>##狄拉克函数：一级逼近的工具
狄拉克函数是我们用来逼近复杂系统的一个重要工具。这个函数在微观世界中尤其重要，因为它可以描述突变和跃变，是连续和离散采样的连通器。狄拉克函数把高维度空间和低维度空间连通起来，揭示了这两个空间之间的关系。因此，我们可以看到离散的现象，这是我们在量子化过程中经常会看到的。</p>

<p>尽管狄拉克函数是一种理想化的工具，其无穷大和无穷小的性质为我们理解现象提供了新的视角，但在实际的应用和数值模拟中，这种一级逼近可能存在困难。</p>

<p>##二级逼近：适应现实的方法
面对实际应用的挑战，我们往往需要采用更加实用的二级逼近方法，例如使用高斯函数或Cauchy分布函数等来模拟狄拉克函数。这种做法虽然会牺牲一部分真相纯度，但却能使我们能够更方便地进行数值模拟和理论分析。</p>

<p>这种二级逼近方法让我们可以更加清楚地看到背后的结构，也方便我们进行实际操作。通过具体的数值模拟和函数，我们能够量化无穷大和无穷小，对它们进行分级和层次化的处理，这对我们理解和模拟现实问题有重要的意义。</p>

<p>##无穷大和无穷小的分级问题
在这个过程中，我们注意到无穷大和无穷小并非简单的概念。无穷大和无穷小实际上存在不同的级别，这是通过比较它们的行为来确定的。这样的处理方式，使得我们能够对无穷大和无穷小进行分级和分层次的处理。</p>

<p>##总结
无论是狄拉克函数的一级逼近，还是更实用的二级逼近方法，我们都在用自己的方式去逼近这个复杂、深奥的真实世界。在追求科学真相的过程中，我们经常需要在理论的严谨性和实用性之间做出权衡，这就是科学的本质。</p>]]></content><author><name></name></author><category term="function" /><category term="approximation" /><category term="delta" /><category term="delta function" /><category term="dirac" /><summary type="html"><![CDATA[Dirac Delta Function and Approaching Truth]]></summary></entry><entry><title type="html">Managing Supply and Demand in a Dairy Retail Business: A Practical Guide to Python and SQLite Database</title><link href="https:///williampolicy.github.io/blog/2023/Managing-Supply-and-Demand-in-a-Dairy-Retail-Business-A-Practical-Guide-to-Python-and-SQLite-Database/" rel="alternate" type="text/html" title="Managing Supply and Demand in a Dairy Retail Business: A Practical Guide to Python and SQLite Database" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Managing-Supply-and-Demand-in-a-Dairy-Retail-Business:-A-Practical-Guide-to-Python-and-SQLite-Database</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Managing-Supply-and-Demand-in-a-Dairy-Retail-Business-A-Practical-Guide-to-Python-and-SQLite-Database/"><![CDATA[<h1 id="managing-supply-and-demand-in-a-dairy-retail-business-a-practical-guide-to-python-and-sqlite-database">Managing Supply and Demand in a Dairy Retail Business: A Practical Guide to Python and SQLite Database</h1>

<h2 id="introduction">Introduction</h2>

<p>In the data-driven world we live in today, databases stand out as some of the most vital tools for storing and managing data. However, using a database correctly and efficiently may require certain skills and knowledge. In this article, we explore how to interact with SQLite databases using Python, tackling a specific problem: managing a family’s consumption and stock of dairy products. The Python libraries we will make use of include <code class="language-plaintext highlighter-rouge">sqlite3</code> and <code class="language-plaintext highlighter-rouge">pandas</code>.</p>

<h2 id="database-design-and-table-initialization">Database Design and Table Initialization</h2>

<p>We start by creating an SQLite database and designing a series of tables to suit our needs. These tables include:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">T1_Family_Consumption</code> which logs the dairy products consumed by the family;</li>
  <li><code class="language-plaintext highlighter-rouge">T2_Dairy_Products</code> that keeps track of inventory;</li>
  <li><code class="language-plaintext highlighter-rouge">T7_Check_Inventory</code>, a trigger for checking inventory;</li>
  <li><code class="language-plaintext highlighter-rouge">T8_Check_Current_Price</code> that records current price information.</li>
</ul>

<p>Having designed these tables, we generate some initial data to kick-start our system. There are two functions, <code class="language-plaintext highlighter-rouge">initialize_consumption()</code> and <code class="language-plaintext highlighter-rouge">initialize_products()</code>, meant for initializing some data at the onset.</p>

<h2 id="database-operations-and-error-handling">Database Operations and Error Handling</h2>

<p>Next, we delve into how to operate these tables, including updating consumption, inventory, price information, creating and invoking triggers, and operating the database using Python.</p>

<p>In the course of operating the database, we encounter some issues, like the <code class="language-plaintext highlighter-rouge">UnboundLocalError</code>, a common error typically caused by not initializing variables correctly before using them. To resolve such problems, an understanding of Python’s namespace and scope, and careful examination of the code to ensure all variables are correctly initialized, is required.</p>

<h2 id="technical-tips">Technical Tips</h2>

<ul>
  <li>When working with SQLite databases, Python’s <code class="language-plaintext highlighter-rouge">sqlite3</code> library offers a convenient way to handle database queries and operations. However, it’s important to remember to call the <code class="language-plaintext highlighter-rouge">commit()</code> method to save changes after operations are completed.</li>
  <li>The <code class="language-plaintext highlighter-rouge">read_sql_query()</code> function from the pandas library is another useful tool for handling SQLite databases. It enables you to transform the results of SQL queries into DataFrames, simplifying subsequent data processing and analysis.</li>
  <li>In database design, different tables should have clear responsibilities, and their relationships should be correctly set. This can be achieved with tools like foreign keys, indexes, and other database design tools.</li>
  <li>While operating the database using Python, make sure to correctly handle errors and exceptions. For instance, an <code class="language-plaintext highlighter-rouge">UnboundLocalError</code> typically means a variable was used before being correctly initialized. In such cases, carefully checking the code to ensure all variables are correctly initialized is important.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Although this article only scratches the surface of how to interact with SQLite databases using Python, we hope it imparts deeper knowledge about database design, the use of triggers, error handling, etc. We look forward to delivering more complex topics in future articles.</p>

<h2 id="开篇">开篇</h2>

<p>在数据驱动的现代世界，数据库是最重要的存储和管理数据的工具之一。然而，正确并有效地使用数据库可能需要具备一定的技能和知识。本文我们将探讨如何通过Python操作SQLite数据库，以处理某家庭奶制品消费和库存管理的问题。我们将使用的Python库包括<code class="language-plaintext highlighter-rouge">sqlite3</code>和<code class="language-plaintext highlighter-rouge">pandas</code>。</p>

<h2 id="数据库设计和数据表初始化">数据库设计和数据表初始化</h2>

<p>我们首先创建了一个SQLite数据库，设计了一系列数据表以适应我们的需求。这些表包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">T1_Family_Consumption</code>记录家庭消费的奶制品信息；</li>
  <li><code class="language-plaintext highlighter-rouge">T2_Dairy_Products</code>记录库存信息；</li>
  <li><code class="language-plaintext highlighter-rouge">T7_Check_Inventory</code>检查库存的触发器；</li>
  <li><code class="language-plaintext highlighter-rouge">T8_Check_Current_Price</code>记录当前价格信息。</li>
</ul>

<p>在设计了这些表后，我们创建了一些初始数据以启动我们的系统。其中有两个函数：<code class="language-plaintext highlighter-rouge">initialize_consumption()</code> 和 <code class="language-plaintext highlighter-rouge">initialize_products()</code> 是用于在开始时初始化一些数据。</p>

<h2 id="数据库操作和错误处理">数据库操作和错误处理</h2>

<p>然后我们深入探讨了如何操作这些表，包括更新消费，库存，价格等信息，创建和调用触发器，以及使用Python操作数据库。</p>

<p>在操作数据库的过程中，我们遇到了一些问题，比如<code class="language-plaintext highlighter-rouge">UnboundLocalError</code>，这个错误通常是由于在使用变量前没有正确的初始化它们。解决这类问题需要理解Python的命名空间和作用域，以及仔细检查代码以确保所有的变量都已正确地初始化。</p>

<h2 id="技术提示-tips">技术提示 (Tips)</h2>

<ul>
  <li>使用SQLite数据库时，Python的<code class="language-plaintext highlighter-rouge">sqlite3</code>库提供了一种方便的方式来处理数据库的查询和操作。然而，需要注意的是，当在Python中执行SQL命令时，一定要记住在操作结束后调用<code class="language-plaintext highlighter-rouge">commit()</code>方法以保存更改。</li>
  <li>在处理SQLite数据库时，Pandas库的<code class="language-plaintext highlighter-rouge">read_sql_query()</code>函数也是一个很有用的工具，它可以将SQL查询的结果转化为DataFrame，这使得后续的数据处理和分析更为简便。</li>
  <li>在设计数据库时，不同的表应该有清晰的职责，并且它们之间的关系应该被正确地设置。这可以通过外键，索引等数据库设计的工具来实现。</li>
  <li>使用Python操作数据库时，要注意正确处理错误和异常。例如，如果遇到<code class="language-plaintext highlighter-rouge">UnboundLocalError</code>，通常是由于在使用变量前没有正确的初始化它们。在这种情况下，应仔细检查代码以确保所有的变量都已正确地初始化。</li>
</ul>

<h2 id="结束">结束</h2>

<p>尽管本文只是简单地探讨了如何通过Python操作SQLite数据库，但希望通过本文，你可以了解到更为深入的知识，如数据库设计，触发器的使用，错误处理等。</p>]]></content><author><name></name></author><category term="python" /><category term="sqlite" /><category term="database" /><category term="correctly" /><category term="consumption" /><summary type="html"><![CDATA[Managing Supply and Demand in a Dairy Retail Business: A Practical Guide to Python and SQLite Database]]></summary></entry><entry><title type="html">Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum</title><link href="https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy-A-Case-Study-on-Food-Attraction-Spectrum/" rel="alternate" type="text/html" title="Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy:-A-Case-Study-on-Food-Attraction-Spectrum</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy-A-Case-Study-on-Food-Attraction-Spectrum/"><![CDATA[<h1 id="mathematical-principles-of-philosophy-a-case-study-on-food-attraction-spectrum">Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum</h1>

<h2 id="1-background">1. Background</h2>

<p>In this case study, we delve into a model aimed at understanding and predicting people’s food selection behaviors. Different foods might carry different weights depending on their various attributes such as nutritional value, taste, and so on. The probability of a food item being selected could vary with factors such as environment, availability, and individual preferences. Specifically, we consider drugs as a special case where the probability of selection is expected to be very low under normal circumstances.</p>

<h2 id="2-purpose">2. Purpose</h2>

<p>Our goal is to devise a quantitative method that captures the aforementioned process and aids in predicting the type of food individuals might select under a given set of conditions. To achieve this, we multiply the weight of a food item by the probability of its selection, followed by normalization to derive the relative attraction of different food items. In this model, we pay special attention to the case of drugs to comprehend how their attraction might change under certain conditions (for instance, when exposure to drugs occurs).</p>

<h2 id="3-method">3. Method</h2>

<p>We first define the weight and probability density for each food item. We then employ the Hadamard product (the product of the weight and probability density) to compute the attraction contribution of each food item. All the attraction contributions are normalized to obtain the relative attractions of various food items. In the case of drugs, we use the Dirac function to describe its probability density, allowing us to capture the potential enormous attraction that drugs may invoke once exposed to individuals.</p>

<h2 id="4-mathematical-expressionrepresentation">4. Mathematical Expression/Representation</h2>

<p>The allure of each food item i, A_i, is calculated by the following equation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A_i = (w_i * p_i) / Σ (w_j * p_j)
</code></pre></div></div>

<p>Here, w_i represents the weight of food i, and p_i denotes the probability density of food i.</p>

<p>For addictive food or drugs, we use the Dirac function as an approximation of its probability density. Mathematically, the Dirac function can be seen as a spike function, which takes an infinite value at a certain point, but its integral (i.e., the area under the curve) is 1. This can be interpreted as at some specific moments, the probability of choosing addictive food or drugs would surge.</p>

<p>Specifically, we can use the following “spike” function as an approximation to the Dirac function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>δ(t-a) ≈ 1/(sqrt(π)*σ) * exp(-((t-a)/σ)^2)
</code></pre></div></div>

<p>Here, a is the time where the spike locates, and σ is a parameter controlling the width of the spike. This function takes its maximum value at t=a, and decreases rapidly as the distance from a increases. When σ-&gt;0, this function tends towards the Dirac function.</p>

<p>For apples and tomatoes, we use periodic functions to describe their probability densities. Specifically, we can use sine and cosine functions to simulate the seasonal influences:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p_apple(t) = 0.5 * (1 + sin(2πt))
p_tomato(t) = 0.5 * (1 + cos(2πt))
</code></pre></div></div>

<p>Here, t stands for time, ranging in [0,1], representing the time within a year. The above functions vary at different times, simulating the availability of different food in different seasons.</p>

<h2 id="5-code">5. Code</h2>

<p>Here is a snippet of the core Python code that was used to simulate the model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Define the weights
</span><span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">Apple</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tomato</span><span class="sh">"</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="sh">"</span><span class="s">Drug</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>

<span class="c1"># Define the probability density functions
</span><span class="k">def</span> <span class="nf">apple_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tomato_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">drug_density</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">0.01</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calculate the attraction
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">attractions</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">weight</span> <span class="o">*</span> <span class="nf">density</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="nf">keys</span><span class="p">(),</span> <span class="p">[</span><span class="n">apple_density</span><span class="p">,</span> <span class="n">tomato_density</span><span class="p">,</span> <span class="n">drug_density</span><span class="p">])}</span>

<span class="c1"># Plot the attraction spectrum
</span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attraction</span> <span class="ow">in</span> <span class="n">attractions</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">attraction</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="6-conclusion">6. Conclusion</h2>

<p>Our model successfully demonstrates how to calculate attractions by considering the weight and probability density of food under different environmental conditions, predicting the potential food selections of individuals. It also illustrates the possible change in attraction in the event of exposure to drugs, helping us understand the impact of drugs on people’s choices.</p>

<h2 id="7-tips">7. Tips</h2>

<ul>
  <li>Our discussion revolved around the use and understanding of the Dirac function. We learned that although the probability density of drugs is zero in general, under certain conditions (like exposure to drugs), its probability density could suddenly increase, invoking a significant attraction.</li>
  <li>We discussed the choice</li>
</ul>

<p>of probability density functions. In this model, we chose periodic functions to describe the probability density for apples and tomatoes, simulating the impact of seasonal variations in food supply on food choices.</p>
<ul>
  <li>We also pondered on the limitations of our model. This model is simplified, and the real situation could be more complicated. For instance, people’s food choices might be influenced by a multitude of factors such as personal preferences, cultural backgrounds, economic conditions, and these factors were not considered in our model.</li>
  <li>Our conversation also touched upon various concepts related to probability, probability density, the Dirac function, and quantum mechanics. For instance, we talked about how the Dirac delta function, often used in quantum mechanics, can be used here to represent a sudden change in probability density when certain conditions are met.
    <h1 id="食物吸引力谱的数学建模一项案例研究">食物吸引力谱的数学建模：一项案例研究</h1>
  </li>
</ul>

<h2 id="1-背景">1. 背景</h2>

<p>在这个案例研究中，我们深入探讨一个旨在理解和预测人们食物选择行为的模型。不同的食物可能因其各种属性（如营养价值，口感等）具有不同的权重。食物被选择的概率可能因环境，可得性以及个人偏好等因素而变化。特别地，我们将成瘾类食物或药物（例如毒品）视为一种特殊情况，期望在正常情况下选择的概率非常低。</p>

<h2 id="2-目的">2. 目的</h2>

<p>我们的目标是设计一种定量方法，捕捉上述过程并有助于预测在给定一组条件下个体可能选择哪种食物。为此，我们将食物的权重与其选择的概率相乘，然后进行归一化以得出不同食物的相对吸引力。在这个模型中，我们特别关注成瘾类食物或药物的情况，以理解其吸引力在某些条件下（例如，当暴露于这类物质时）可能如何改变。</p>

<h2 id="3-方法">3. 方法</h2>

<p>我们首先为每种食物定义权重和概率密度。然后，我们使用哈达玛积（权重和概率密度的积）计算每种食物的吸引力贡献。所有的吸引力贡献都进行归一化，以获得各种食物的相对吸引力。对于成瘾类食物或药物，我们使用狄拉克函数来描述其概率密度，从而捕捉到这类物质一旦暴露给个体可能引起的巨大吸引力。</p>

<h2 id="4-数学表达">4. 数学表达</h2>

<p>对于每种食物i，其吸引力A_i可以通过以下方程计算：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A_i = (w_i * p_i) / Σ (w_j * p_j)
</code></pre></div></div>

<p>这里，w_i代表食物i的权重，p_i表示食物i的概率密度。</p>

<p>对于成瘾类食物或药物，我们使用狄拉克函数作为其概率密度的近似。在数学上，狄拉克函数可以视作一个尖峰函数，其在某一点的值为无穷大，但其积分（即面积）为1。这可以被解释为在某些特定时刻，成瘾类食物或药物的选择概率会剧增。</p>

<p>具体来说，我们可以用如下的“突刺”函数作为狄拉克函数的近似：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>δ(t-a) ≈ 1/(sqrt(π)*σ) * exp(-((t-a)/σ)^2)
</code></pre></div></div>

<p>这里，a是尖峰所在的时间，σ是控制尖峰宽度的参数。这样的函数在t=a时有最大值，并且随着离a的距离增大而快速下降。当σ-&gt;0时，这个函数趋向于狄拉克函数。</p>

<p>对于苹果和番茄，我们使用周期函数来描述它们的概率密度。具体来说，我们可以用正弦函数和余弦函数来模拟季节性的影响：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p_apple(t) = 0.5 * (1 + sin(2πt))
p_tomato(t) = 0.5 * (1 + cos(2πt))
</code></pre></div></div>

<p>这里，t代表时间，取值范围为[0,1]，表示一年中的时间。上述函数在不同的时间取值会有所不同，模拟了不同食物在不同季节的可得性。</p>

<p>对于每种食物i，其吸引力A_i可以通过以下方程计算：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A_i = (w_i * p_i) / Σ (w_j * p_j)
</code></pre></div></div>

<p>这里，w_i代表食物i的权重，p_i表示食物i的概率密度。对于成瘾类食物或药物，我们使用狄拉克函数来描述其概率密度。</p>

<p>对于苹果和番茄，我们使用周期函数来描述它们的概率密度。</p>

<h2 id="5-代码">5. 代码</h2>

<p>这是用来模拟模型的核心Python代码的一部分：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># 定义权重
</span><span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">Apple</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tomato</span><span class="sh">"</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="sh">"</span><span class="s">Addictive Substance</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>

<span class="c1"># 定义概率密度函数
</span><span class="k">def</span> <span class="nf">apple_density</span><span class="p">(</span><span class="n">t</span>

<span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tomato_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">addictive_substance_density</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="c1"># 这里省略了成瘾物质的概率密度函数的具体实现。
</span>    <span class="k">pass</span>
</code></pre></div></div>

<h2 id="6-结论">6. 结论</h2>

<p>通过这种方式，我们可以通过调整权重和概率密度来模拟各种环境和个体条件下食物的吸引力。我们的模型特别强调成瘾类食物或药物在某些条件下（如当个体被暴露在这类物质中时）的巨大吸引力。</p>

<h2 id="7-提示和注意事项">7. 提示和注意事项</h2>

<ul>
  <li>本模型的一个重要前提是，所有食物的权重和概率密度都是已知的，这在实际应用中可能并不总是成立。</li>
  <li>狄拉克函数用于描述成瘾类食物或药物的概率密度，这是一个理想化的表示。实际上，这类物质的吸引力可能因人而异，取决于个体的生理和心理状态。</li>
  <li>我们的讨论中提到了一些与量子力学相关的概念，比如狄拉克函数和概率密度。然而，这些只是为了提供一个对概念的直观理解，而并非指这个模型具有与量子力学类似的性质。</li>
  <li>尽管我们使用了周期函数来描述苹果和番茄的概率密度，但实际上食物的可得性可能会受到更复杂的因素的影响，比如气候变化，季节变化，农业实践等。</li>
  <li>最后，本模型只是对食物选择行为的一种简化表示，而在实际中，食物选择可能受到许多其他因素的影响，比如文化，社会经济状态，健康状况等。</li>
</ul>]]></content><author><name></name></author><category term="density" /><category term="food" /><category term="probability" /><category term="p" /><category term="probability density" /><summary type="html"><![CDATA[Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum]]></summary></entry><entry><title type="html">Quantum State Analysis: A Conceptual Understanding and Computation</title><link href="https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis-A-Conceptual-Understanding-and-Computation/" rel="alternate" type="text/html" title="Quantum State Analysis: A Conceptual Understanding and Computation" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis:-A-Conceptual-Understanding-and-Computation</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis-A-Conceptual-Understanding-and-Computation/"><![CDATA[<h1 id="quantum-state-analysis-a-conceptual-understanding-and-computation">Quantum State Analysis: A Conceptual Understanding and Computation</h1>

<h2 id="background">Background</h2>

<p>The concept of weight and probability density spectra can be generalized to various scientific domains, including quantum physics. This approach can facilitate a comprehensive understanding and analysis of complex systems. In the realm of quantum physics, the probability amplitude of a quantum state can be perceived as a form of “weight,” and its modulus squared (probability density) can be analyzed in tandem with this weight to draw meaningful conclusions about the system.</p>

<h2 id="concepts">Concepts</h2>

<p>In quantum physics, the state of a quantum system is often represented by a wave function, a mathematical description that provides information about the probability amplitude of finding the system in different states. These amplitude coefficients can be perceived as the “weight” of each state. The modulus squared of these amplitude coefficients gives us the “probability density” of finding the system in that specific state.</p>

<p>When the “weights” (probability amplitudes) and “probability densities” (modulus squared of amplitudes) are multiplied, we get a spectrum representing the contribution of each quantum state to the overall quantum system. This can be used to compute various expectation values, providing vital information about the behavior of the system.</p>

<h2 id="mathematical-description">Mathematical Description</h2>

<table>
  <tbody>
    <tr>
      <td>Let’s denote the probability amplitude (weight) for each state as $A = [a_1, a_2, …, a_n]$, where $a_i$ is the amplitude of the $i^{th}$ state. The probability density of each state, given by the modulus squared of the amplitude, is then $P = [</td>
      <td>a_1</td>
      <td>^2,</td>
      <td>a_2</td>
      <td>^2, …,</td>
      <td>a_n</td>
      <td>^2]$.</td>
    </tr>
  </tbody>
</table>

<p>The contribution of each state to the overall system, which we’ll refer to as the “quantum contribution spectrum”, $Q$, is then the Hadamard product of the weight and probability density spectra:</p>

<table>
  <tbody>
    <tr>
      <td>$Q = A \circ P = [a_1 \cdot</td>
      <td>a_1</td>
      <td>^2, a_2 \cdot</td>
      <td>a_2</td>
      <td>^2, …, a_n \cdot</td>
      <td>a_n</td>
      <td>^2]$</td>
    </tr>
  </tbody>
</table>

<p>Each component $q_i$ of the quantum contribution spectrum $Q$ then represents the contribution of the $i^{th}$ quantum state to the overall quantum system.</p>

<h2 id="example">Example</h2>

<p>In Python, this can be computed quite simply using the <code class="language-plaintext highlighter-rouge">numpy</code> library:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># example amplitudes for three quantum states
</span><span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">0.2j</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">])</span>

<span class="c1"># compute the probability densities
</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># compute the quantum contribution spectrum
</span><span class="n">contribution_spectrum</span> <span class="o">=</span> <span class="n">amplitudes</span> <span class="o">*</span> <span class="n">probabilities</span>
<span class="nf">print</span><span class="p">(</span><span class="n">contribution_spectrum</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>The quantum contribution spectrum provides an effective way to evaluate the contribution of individual quantum states to the overall quantum system. This concept, akin to the food consumption spectrum, allows us to incorporate both the significance and likelihood of different states to gain a comprehensive understanding of the quantum system.</p>

<h1 id="量子态分析概念理解与计算">量子态分析：概念理解与计算</h1>

<h2 id="背景">背景</h2>

<p>权重和概率密度谱的概念可以推广到包括量子物理学在内的各种科学领域。这种方法有助于全面理解和分析复杂的系统。在量子物理领域，量子态的概率振幅可以被视为一种“权重”，其模方（概率密度）可以与这个权重一起分析，以得出关于系统的有意义的结论。</p>

<h2 id="概念">概念</h2>

<p>在量子物理中，量子系统的状态通常由一个波函数表示，这是一个数学描述，提供了关于在不同状态下发现系统的概率振幅的信息。这些振幅系数可以被视为每个状态的”权重”。这些振幅系数的模方给出了在特定状态下找到系统的“概率密度”。</p>

<p>当”权重”（概率振幅）和”概率密度”（振幅模方）相乘时，我们得到一个表示每个量子态对整个量子系统贡献的谱。这可以用来计算各种期望值，提供关于系统行为的重要信息。</p>

<h2 id="数学描述">数学描述</h2>

<table>
  <tbody>
    <tr>
      <td>让我们把每个状态的概率振幅（权重）表示为 $A = [a_1, a_2, …, a_n]$，其中 $a_i$ 是第 $i$ 个状态的振幅。每个状态的概率密度，由振幅的模方给出，那么就是 $P = [</td>
      <td>a_1</td>
      <td>^2,</td>
      <td>a_2</td>
      <td>^2, …,</td>
      <td>a_n</td>
      <td>^2]$。</td>
    </tr>
  </tbody>
</table>

<p>每个状态对整个系统的贡献，我们将其称为”量子贡献谱”，$Q$，是权重谱和概率密度谱的哈达玛积：</p>

<table>
  <tbody>
    <tr>
      <td>$Q = A \circ P = [a_1 \cdot</td>
      <td>a_1</td>
      <td>^2, a_2 \cdot</td>
      <td>a_2</td>
      <td>^2, …, a_n \cdot</td>
      <td>a_n</td>
      <td>^2]$</td>
    </tr>
  </tbody>
</table>

<p>量子贡献谱 $Q$ 的每个组成部分 $q_i$ 都表示第 $i$ 个量子态对整个量子系统的贡献。</p>

<h2 id="例子">例子</h2>

<p>在 Python 中，这可以使用 <code class="language-plaintext highlighter-rouge">numpy</code> 库简单地计算：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># 三个量子态的例子振幅
</span><span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">0.2j</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">])</span>

<span class="c1"># 计算概率密度
</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># 计算量子贡献谱
</span><span class="n">contribution_spectrum</span> <span class="o">=</span> <span class="n">amplitudes</span> <span class="o">*</span> <span class="n">probabilities</span>
<span class="nf">print</span><span class="p">(</span><span class="n">contribution_spectrum</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="结论">结论</h2>

<p>量子贡献谱提供了一种有效的方法来评</p>

<p>估各个量子态对整个量子系统的贡献。这个概念类似于食物消费谱，让我们能够既考虑不同状态的重要性，也考虑它们发生的可能性，从而全面理解量子系统。</p>]]></content><author><name></name></author><category term="quantum" /><category term="contribution" /><category term="probability" /><category term="state" /><category term="spectrum" /><summary type="html"><![CDATA[Quantum State Analysis: A Conceptual Understanding and Computation]]></summary></entry><entry><title type="html">Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra</title><link href="https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns-Weights,-Probabilities,-and-Consumption-Spectra/" rel="alternate" type="text/html" title="Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns:-Weights,-Probabilities,-and-Consumption-Spectra</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns-Weights,-Probabilities,-and-Consumption-Spectra/"><![CDATA[<h1 id="understanding-food-consumption-patterns-weights-probabilities-and-consumption-spectra">Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra</h1>

<h2 id="1-background">1. Background</h2>

<p>In this study, we analyze food consumption patterns, more specifically, we delve into the weights and probabilities of food items, ultimately arriving at a food consumption spectrum. This problem can be considered both in discrete and continuous forms.</p>

<h2 id="2-methodology">2. Methodology</h2>

<p>Our method isn’t solely reliant on the perspective of neural networks. We can view the weights and probabilities of food items as independent variables, and then compute their Hadamard product (i.e., element-wise multiplication) to obtain the food consumption spectrum.</p>

<h2 id="3-mathematical-description">3. Mathematical Description</h2>

<p>In discrete form, we have n food items, each food item i has a weight <code class="language-plaintext highlighter-rouge">$w_i$</code> and a probability <code class="language-plaintext highlighter-rouge">$p_i$</code>. Hence, the food consumption spectrum <code class="language-plaintext highlighter-rouge">$c_i$</code> can be expressed as:</p>

<pre><code class="language-math">c_i = w_i \cdot p_i, \quad i=1, 2, ..., n.
</code></pre>

<p>In continuous form, we consider the weights and probabilities of food items as functions <code class="language-plaintext highlighter-rouge">$w(x)$</code> and <code class="language-plaintext highlighter-rouge">$p(x)$</code> defined over some interval, and then compute the food consumption spectrum <code class="language-plaintext highlighter-rouge">$c(x)$</code>:</p>

<pre><code class="language-math">c(x) = w(x) \cdot p(x), \quad x \in [a, b].
</code></pre>

<h2 id="4-example">4. Example</h2>

<p>For instance, we have three food items, with weights <code class="language-plaintext highlighter-rouge">$w_1 = 0.5, w_2 = 0.3, w_3 = 0.2$</code> and probabilities <code class="language-plaintext highlighter-rouge">$p_1 = 0.4, p_2 = 0.5, p_3 = 0.1$</code> respectively. Hence, the food consumption spectrum for these food items are <code class="language-plaintext highlighter-rouge">$c_1 = 0.5 \cdot 0.4 = 0.2, c_2 = 0.3 \cdot 0.5 = 0.15, c_3 = 0.2 \cdot 0.1 = 0.02$</code>.</p>

<p>We can compute these using the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>

<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="o">*</span><span class="n">pi</span> <span class="k">for</span> <span class="n">wi</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># prints: [0.2, 0.15, 0.02]
</span></code></pre></div></div>

<h2 id="5-conclusion">5. Conclusion</h2>

<p>Through the analysis of food weights and probabilities, we have arrived at a food consumption spectrum. Leveraging these independent variables, we’ve gained a fresh perspective on analyzing and understanding food consumption patterns.</p>

<hr />

<h1 id="理解食物消费模式权重概率和消费谱">理解食物消费模式：权重，概率和消费谱</h1>

<h2 id="1-背景">1. 背景</h2>

<p>在这个项目中，我们研究了食物消费模式，具体来说，我们分析了食物的权重和概率，最后得到了食物消费谱。这个问题可以通过离散和连续两种方式来考虑。</p>

<h2 id="2-方法">2. 方法</h2>

<p>我们的方法不仅限于神经网络的视角，我们可以将食物的权重和概率看作是独立的变量，然后通过计算它们的哈达玛积（Hadamard product，即逐元素相乘）来得到食物消费谱。</p>

<h2 id="3-数学描述">3. 数学描述</h2>

<p>在离散形式下，我们有n种食物，每种食物i有一个权重<code class="language-plaintext highlighter-rouge">$w_i$</code>和一个概率<code class="language-plaintext highlighter-rouge">$p_i$</code>，那么食物消费谱<code class="language-plaintext highlighter-rouge">$c_i$</code>可以表示为:</p>

<pre><code class="language-math">c_i = w_i \cdot p_i, \quad i=1, 2, ..., n.
</code></pre>

<p>在连续形式下，我们将食物的权重和概率看作是定义在某个区间上的函数<code class="language-plaintext highlighter-rouge">$w(x)$</code>和<code class="language-plaintext highlighter-rouge">$p(x)$</code>，然后计算得到食物消费谱<code class="language-plaintext highlighter-rouge">$c(x)$</code>：</p>

<pre><code class="language-math">c(x) = w(x) \cdot p(x), \quad x \in [a, b].
</code></pre>

<h2 id="4-案例">4. 案例</h2>

<p>例如，我们有三种食物，它们的权重分别为<code class="language-plaintext highlighter-rouge">$w_1 = 0.5, w_2 = 0.3, w_3 = 0.2$</code>，概率分别为<code class="language-plaintext highlighter-rouge">$p_1 = 0.4, p_2 = 0.5, p_3 = 0.1$</code>，那么这三种食物的消费谱分别为<code class="language-plaintext highlighter-rouge">$c_1 = 0.5 \cdot 0.4 = 0.2, c_2 = 0.3 \cdot 0.5 = 0.15, c_3 = 0.2 \cdot 0.1 = 0.02$</code>。</p>

<p>我们可以通过以下的Python代码来计算这个结果：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>

<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="o">*</span><span class="n">pi</span> <span class="k">for</span> <span class="n">wi</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># prints: [0.2, 0.15, 0.02]
</span></code></pre></div></div>

<h2 id="5-总结">5. 总结</h2>

<p>通过对食物权重和概率的分析，我们得到了食物消费谱。我们利用这些独立的变量，这为我们分析和理解食物消费模式提供了一个新的视角。</p>

<hr />]]></content><author><name></name></author><category term="c" /><category term="p" /><category term="w" /><category term="food" /><category term="x" /><summary type="html"><![CDATA[Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra]]></summary></entry><entry><title type="html">Automating Blog Publication and Versioning with Python</title><link href="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/" rel="alternate" type="text/html" title="Automating Blog Publication and Versioning with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/"><![CDATA[<h1 id="automating-blog-publication-and-versioning-with-python">Automating Blog Publication and Versioning with Python</h1>

<p>In the hustle and bustle of daily work, we often gain insights and accumulate knowledge that we’d like to share with others or keep for future reference. This is where blogging becomes an essential tool for expressing our ideas, sharing our learning, and reflecting on our experiences. However, the process of drafting, formatting, and publishing a blog post, especially when we want to do it frequently, can be time-consuming. To streamline this process and allow for more efficient knowledge sharing, we have devised an automation solution using Python, which enables us to publish and version our blogs with a single command.</p>

<p>The tool we’ve created offers several key features:</p>

<ol>
  <li>
    <p><strong>Preprocessing of Blog Files</strong>: The script can transform a text file into a specific format that is ready for publication, including extracting categories from the text, generating YAML front matter, and adjusting the title format.</p>
  </li>
  <li>
    <p><strong>Git Commit</strong>: After the preprocessing is done, the script will automatically commit the new blog file to a Git repository. The commit message includes the new version number, a user-defined commit message, the username, and a timestamp.</p>
  </li>
  <li>
    <p><strong>Version Control</strong>: After each commit, the new version number and associated details are written into a text file, allowing for easy tracking of versions.</p>
  </li>
</ol>

<p>使用此工具，不仅可以使博客发布过程变得自动化，而且通过版本控制，也方便我们追踪每个版本的变化，非常实用。以下是此工具的使用流程：</p>

<ol>
  <li>首先，我们使用argparse处理命令行参数，包括输入的文件名和提交信息。</li>
  <li>然后，使用nltk对文本进行预处理，从而提取文章的类别。</li>
  <li>通过get_title函数获取文章的标题，并进行格式化处理。</li>
  <li>create_blog_post函数则创建了新的博客文件，其中包含YAML前置内容和原始的文章内容。</li>
  <li>commit_version_to_git函数处理Git提交和版本控制。它首先读取版本文件，获取当前的版本号，然后进行版本号的递增，并进行Git的add、commit和push操作。最后，更新版本文件。</li>
</ol>

<p>总的来说，通过这个Python脚本，我们可以用一行命令就完成博客的预处理，Git提交以及版本控制，极大地提高了工作效率。不仅如此，它也为我们提供了一种方便的方式，快速分享和记录我们的知识和经验。</p>]]></content><author><name></name></author><category term="commit" /><category term="git" /><category term="blog" /><category term="version" /><category term="file" /><summary type="html"><![CDATA[Automating Blog Publication and Versioning with Python]]></summary></entry></feed>