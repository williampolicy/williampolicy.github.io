<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https:///williampolicy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https:///williampolicy.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-26T20:23:24+00:00</updated><id>https:///williampolicy.github.io/feed.xml</id><title type="html">blank</title><subtitle>I would want to make a set [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/" rel="alternate" type="text/html" title="" /><published>2023-06-26T20:23:24+00:00</published><updated>2023-06-26T20:23:24+00:00</updated><id>https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/"><![CDATA[<p>Today we explored how to integrate OpenAI’s GPT-3 into an iOS application using Swift. This process mainly involves setting up API requests, handling response data, and testing in a simulator. In this process, we also used Git for version control and error tracking.</p>

<h2 id="setting-up-api-requests">Setting Up API Requests</h2>
<p>We first created a function in Swift to set up the API request. This function takes an input prompt and sends it to the OpenAI API to generate GPT-3 output. We used the <code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code> function to send the request and <code class="language-plaintext highlighter-rouge">JSONSerialization</code> to convert the returned data into a JSON format we can handle.</p>

<h2 id="handling-api-responses">Handling API Responses</h2>
<p>When handling the API response, we focused on the <code class="language-plaintext highlighter-rouge">choices</code> field, which contains the text generated by GPT-3. We took the first choice from this field and returned it as the result of the function.</p>

<h2 id="testing-in-simulator">Testing in Simulator</h2>
<p>Next, we tested in the iOS simulator. We used the command-line tool <code class="language-plaintext highlighter-rouge">xcrun simctl</code> to manage the simulator and the <code class="language-plaintext highlighter-rouge">xcrun simctl launch</code> command to launch our application. When the application runs in the simulator, we can see all the output of the print() statements in the console, including any error messages, which is very useful for debugging.</p>

<h2 id="using-git-for-version-control-and-error-tracking">Using Git for Version Control and Error Tracking</h2>
<p>When we encountered errors, we used Git for error tracking.</p>

<hr />

<p><strong>layout:</strong> post</p>

<p><strong>title:</strong> “集成GPT-3到iOS应用中：使用Swift进行OpenAI API调用”</p>

<p><strong>date:</strong> 2023-06-19</p>

<p><strong>categories:</strong> [OpenAI, GPT-3, iOS, Swift, App Development]</p>

<hr />

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<h2 id="创建api请求">创建API请求</h2>
<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用<code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code>函数发送请求，并使用<code class="language-plaintext highlighter-rouge">JSONSerialization</code>将返回的数据转换为我们可以处理的JSON格式。</p>

<h2 id="处理api响应">处理API响应</h2>
<p>在处理API响应时，我们主要关注的是<code class="language-plaintext highlighter-rouge">choices</code>字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<h2 id="在模拟器中进行测试">在模拟器中进行测试</h2>
<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具<code class="language-plaintext highlighter-rouge">xcrun simctl</code>来管理模拟器，并使用<code class="language-plaintext highlighter-rouge">xcrun simctl launch</code>命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用URLSession.shared.dataTask(with:completionHandler:)函数发送请求，并使用JSONSerialization将返回的数据转换为我们可以处理的JSON格式。</p>

<p>在处理API响应时，我们主要关注的是choices字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具xcrun simctl来管理模拟器，并使用xcrun simctl launch命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>当我们遇到错误时，我们使用Git进行错误跟踪。我们首先使用git diff查看自上次提交以来我们做了哪些改动，然后使用git log查看提交历史，找出可能导致错误的提交。一旦找到错误，我们就可以使用git revert来撤销这个提交，然后再进行修复。</p>

<p>当我们的应用正常运行并能够产生期望的输出时，我们使用Git来保存这个版本。我们首先使用git add .将所有改动添加到暂存区，然后使用git commit -m提交这些改动，并添加一个描述性的消息。最后，我们使用git tag添加一个标签来标记这个版本，然后使用git push将这个标签推送到远程仓库。</p>

<p>今天的工作中，我们学到了很多关于如何集成OpenAI的GPT-3到iOS应用中，如何在模拟器中进行测试，以及如何使用Git进行版本控制和错误跟踪的知识。我们还通过实际的操作，熟悉了这些工具和技术的应用。希望这个经验对你的工作也有所帮</p>]]></content><author><name></name></author></entry><entry><title type="html">Automating Blog Publication and Versioning with Python</title><link href="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/" rel="alternate" type="text/html" title="Automating Blog Publication and Versioning with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/"><![CDATA[<h1 id="automating-blog-publication-and-versioning-with-python">Automating Blog Publication and Versioning with Python</h1>

<p>In the hustle and bustle of daily work, we often gain insights and accumulate knowledge that we’d like to share with others or keep for future reference. This is where blogging becomes an essential tool for expressing our ideas, sharing our learning, and reflecting on our experiences. However, the process of drafting, formatting, and publishing a blog post, especially when we want to do it frequently, can be time-consuming. To streamline this process and allow for more efficient knowledge sharing, we have devised an automation solution using Python, which enables us to publish and version our blogs with a single command.</p>

<p>The tool we’ve created offers several key features:</p>

<ol>
  <li>
    <p><strong>Preprocessing of Blog Files</strong>: The script can transform a text file into a specific format that is ready for publication, including extracting categories from the text, generating YAML front matter, and adjusting the title format.</p>
  </li>
  <li>
    <p><strong>Git Commit</strong>: After the preprocessing is done, the script will automatically commit the new blog file to a Git repository. The commit message includes the new version number, a user-defined commit message, the username, and a timestamp.</p>
  </li>
  <li>
    <p><strong>Version Control</strong>: After each commit, the new version number and associated details are written into a text file, allowing for easy tracking of versions.</p>
  </li>
</ol>

<p>使用此工具，不仅可以使博客发布过程变得自动化，而且通过版本控制，也方便我们追踪每个版本的变化，非常实用。以下是此工具的使用流程：</p>

<ol>
  <li>首先，我们使用argparse处理命令行参数，包括输入的文件名和提交信息。</li>
  <li>然后，使用nltk对文本进行预处理，从而提取文章的类别。</li>
  <li>通过get_title函数获取文章的标题，并进行格式化处理。</li>
  <li>create_blog_post函数则创建了新的博客文件，其中包含YAML前置内容和原始的文章内容。</li>
  <li>commit_version_to_git函数处理Git提交和版本控制。它首先读取版本文件，获取当前的版本号，然后进行版本号的递增，并进行Git的add、commit和push操作。最后，更新版本文件。</li>
</ol>

<p>总的来说，通过这个Python脚本，我们可以用一行命令就完成博客的预处理，Git提交以及版本控制，极大地提高了工作效率。不仅如此，它也为我们提供了一种方便的方式，快速分享和记录我们的知识和经验。</p>]]></content><author><name></name></author><category term="commit" /><category term="git" /><category term="blog" /><category term="version" /><category term="file" /><summary type="html"><![CDATA[Automating Blog Publication and Versioning with Python]]></summary></entry><entry><title type="html">Creating Custom Version Control Tool with Python</title><link href="https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python/" rel="alternate" type="text/html" title="Creating Custom Version Control Tool with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python/"><![CDATA[<h1 id="creating-custom-version-control-tool-with-python">Creating Custom Version Control Tool with Python</h1>

<p>new edition:</p>

<p>Version control is vital when it comes to software development. It allows us to track changes in our code, understand when and why each change was made, and who made the change. Let’s look at how to create our own version control tool using Python.</p>

<h2 id="step-1-creating-a-python-script">Step 1: Creating a Python Script</h2>

<p>Firstly, we create a Python script named <code class="language-plaintext highlighter-rouge">version_control.py</code>, which will generate new version numbers for our codebase. This script uses Python’s <code class="language-plaintext highlighter-rouge">os</code> and <code class="language-plaintext highlighter-rouge">re</code> modules and contains a function named <code class="language-plaintext highlighter-rouge">main</code> to execute version control.</p>

<p>This function first checks if a file named <code class="language-plaintext highlighter-rouge">version.txt</code> exists, and if not, it creates one and writes the initial version <code class="language-plaintext highlighter-rouge">V.0.1</code>. Next, the function reads the content of <code class="language-plaintext highlighter-rouge">version.txt</code>, finds the latest version number, and increments it by 1 to create a new version. It then updates the <code class="language-plaintext highlighter-rouge">version.txt</code> file and runs some git commands to commit the new version.</p>

<h2 id="step-2-creating-a-python-package">Step 2: Creating a Python Package</h2>

<p>To turn our Python script into a reusable tool, we need to create a Python package. To start, we create a directory named <code class="language-plaintext highlighter-rouge">kangtools</code> under our project directory and place the <code class="language-plaintext highlighter-rouge">version_control.py</code> file into this directory.</p>

<p>We also need to create a <code class="language-plaintext highlighter-rouge">__init__.py</code> file, which exports the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file as the API of our package.</p>

<p>Finally, we need to create a <code class="language-plaintext highlighter-rouge">setup.py</code> file, which describes our package and its metadata like name, version, author, etc. In the <code class="language-plaintext highlighter-rouge">setup.py</code> file, we also define a command-line interface that allows us to run the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file directly from the command line.</p>

<h2 id="step-3-installing-and-using-our-tool">Step 3: Installing and Using Our Tool</h2>

<p>We can install our tool using the <code class="language-plaintext highlighter-rouge">pip</code> command, just like installing any other Python package. Once installed, we can directly run the <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> command from the command line to use our tool. This command will prompt us to input a commit message, then generate a new version number and commit it to our codebase.</p>

<h2 id="done">Done!</h2>

<p>Now, you know how to create your own version control tool using Python. This is just a start, and you can modify this tool as per your needs. For example, you could make the tool support more complex version number formats, or make it work with other version control systems.</p>

<h2 id="download-instructions">Download Instructions</h2>

<p>You can directly download our package on PyPi: https://pypi.org/project/kangtools/</p>

<p>Installation: <code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>Usage: <code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p><em>Note: Before using this tool, make sure your codebase has been initialized as a git repository and that you have set up your git username and email.</em></p>

<p>Enjoy!</p>

<p><em>Disclaimer: This article is for educational purposes only, for actual version control applications, tools such as Git are usually used.</em></p>

<h1 id="使用-python-创建自定义的版本控制工具">使用 Python 创建自定义的版本控制工具</h1>

<p>在进行软件开发时，版本控制是至关重要的。它允许我们跟踪代码的更改，理解每个更改发生的时间和原因，以及谁进行了更改。让我们来看看如何使用 Python 来创建我们自己的版本控制工具。</p>

<h2 id="步骤-1-创建-python-脚本">步骤 1: 创建 Python 脚本</h2>

<p>我们首先创建一个 Python 脚本 <code class="language-plaintext highlighter-rouge">version_control.py</code>，这个脚本将为我们的代码库生成新的版本号。这个脚本使用 Python 的 <code class="language-plaintext highlighter-rouge">os</code> 和 <code class="language-plaintext highlighter-rouge">re</code> 模块，并包含一个名为 <code class="language-plaintext highlighter-rouge">main</code> 的函数，用于执行版本控制。</p>

<p>这个函数首先检查一个名为 <code class="language-plaintext highlighter-rouge">version.txt</code> 的文件是否存在，如果不存在，就创建它并写入初始版本号 <code class="language-plaintext highlighter-rouge">V.0.1</code>。然后，这个函数读取 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件的内容，找到最新的版本号，并将其加 1 以生成新的版本号。然后，这个函数更新 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件，并执行一些 git 命令来提交新的版本。</p>

<h2 id="步骤-2-创建-python-包">步骤 2: 创建 Python 包</h2>

<p>为了将我们的 Python 脚本转化为一个可复用的工具，我们需要创建一个 Python 包。首先，我们需要在我们的项目目录下创建一个名为 <code class="language-plaintext highlighter-rouge">kangtools</code> 的目录，然后将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件放入这个目录中。</p>

<p>我们还需要创建一个 <code class="language-plaintext highlighter-rouge">__init__.py</code> 文件，这个文件将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数导出为这个包的 API。</p>

<p>最后，我们需要创建一个 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件，这个文件描述了我们的包以及它的元数据，如名称、版本、作者等。在 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件中，我们还定义了一个命令行接口，允许我们直接从命令行运行 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数。</p>

<h2 id="步骤-3-安装并使用我们的工具">步骤 3: 安装并使用我们的工具</h2>

<p>我们可以使用 <code class="language-plaintext highlighter-rouge">pip</code> 命令来安装我们的工具，就像安装其他 Python 包一样。安装完成后，我们可以直接在命令行中运行 <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> 命令来使用我们的工具。这个命令将提示我们输入一个提交消息，然后生成一个新的版本号，并将它提交到我们的代码库。</p>

<h2 id="完成">完成!</h2>

<p>现在，你已经了解了如何使用 Python 创建自己的版本控制工具。这只是开始，你可以根据自己的需要修改这个工具，例如，你可以让这个工具支持更复杂的版本号格式，或者让它与其他的版本控制系统一起工作。</p>

<h2 id="下载方式">下载方式</h2>

<p>你可以直接在 PyPi 上下载我们的包：https://pypi.org/project/kangtools/</p>

<p>安装方式：<code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>使用方式：<code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p>*注意：使用这个工具</p>

<p>前，请确保你的代码库已经初始化为 git 仓库，并且你已经配置好了 git 的用户名和邮箱。*</p>

<p>祝你使用愉快！</p>

<p><em>注：该文章仅用于教学目的，实际的版本控制应用场景通常会使用更成熟的工具，如 Git。</em></p>]]></content><author><name></name></author><category term="version" /><category term="python" /><category term="control" /><category term="version control" /><category term="py" /><summary type="html"><![CDATA[Creating Custom Version Control Tool with Python]]></summary></entry><entry><title type="html">Streamlining PyPi Package Release with Automation and Version Control</title><link href="https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control/" rel="alternate" type="text/html" title="Streamlining PyPi Package Release with Automation and Version Control" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control/"><![CDATA[<h1 id="streamlining-pypi-package-release-with-automation-and-version-control">Streamlining PyPi Package Release with Automation and Version Control</h1>

<p>As developers, we often build packages that help others in our community solve complex problems. Sharing these packages on platforms like PyPi allows users worldwide to access, download, and benefit from our creations. However, managing the versioning, building, and releasing of a package can sometimes be a cumbersome process.</p>

<p>To enhance the efficiency and accuracy of this process, we have devised a Python-based solution that automates the lifecycle of a PyPi package. This solution focuses on three key stages: versioning, building, and releasing.</p>

<ol>
  <li>
    <p><strong>Versioning</strong>: The script automates the versioning process by maintaining a version.txt file. Each new version number is appended to this file, along with the timestamp, aiding in version tracking.</p>
  </li>
  <li>
    <p><strong>Building</strong>: The script leverages Python’s setuptools and wheel to build the package. The ‘setup.py’ file, which contains necessary metadata, is automatically updated with each version release.</p>
  </li>
  <li>
    <p><strong>Releasing</strong>: The script uses twine to upload the package to PyPi. Twine is a utility that enables you to publish Python packages over PyPi securely.</p>
  </li>
</ol>

<p>An additional feature of this automation solution is the inclusion of a command-line interface. Users can execute a single command that automates the entire lifecycle of the package.</p>

<p>Here’s an overview of the workflow:</p>

<ol>
  <li>The argparse module is used to handle command-line arguments, which includes the package name.</li>
  <li>The version number is automatically incremented and updated in the ‘setup.py’ file and the ‘version.txt’ file.</li>
  <li>The script then removes old distributions and builds new ones using setuptools and wheel.</li>
  <li>Finally, the newly built distribution is uploaded to PyPi using twine.</li>
</ol>

<p>In conclusion, this Python script significantly simplifies the management and release of PyPi packages. By automating version control, package building, and releasing, it not only saves time but also minimizes the chances of manual error. This solution is especially useful for developers who regularly maintain and release Python packages on PyPi.</p>]]></content><author><name></name></author><category term="package" /><category term="pypi" /><category term="version" /><category term="file" /><category term="packages" /><summary type="html"><![CDATA[Streamlining PyPi Package Release with Automation and Version Control]]></summary></entry><entry><title type="html">TEST 1</title><link href="https:///williampolicy.github.io/blog/2023/TEST-1/" rel="alternate" type="text/html" title="TEST 1" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/TEST-1</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/TEST-1/"><![CDATA[<h1 id="test-1">TEST 1</h1>

<p>new edition:</p>

<p>Version control is vital when it comes to software development. It allows us to track changes in our code, understand when and why each change was made, and who made the change. Let’s look at how to create our own version control tool using Python.</p>

<h2 id="step-1-creating-a-python-script">Step 1: Creating a Python Script</h2>

<p>Firstly, we create a Python script named <code class="language-plaintext highlighter-rouge">version_control.py</code>, which will generate new version numbers for our codebase. This script uses Python’s <code class="language-plaintext highlighter-rouge">os</code> and <code class="language-plaintext highlighter-rouge">re</code> modules and contains a function named <code class="language-plaintext highlighter-rouge">main</code> to execute version control.</p>

<p>This function first checks if a file named <code class="language-plaintext highlighter-rouge">version.txt</code> exists, and if not, it creates one and writes the initial version <code class="language-plaintext highlighter-rouge">V.0.1</code>. Next, the function reads the content of <code class="language-plaintext highlighter-rouge">version.txt</code>, finds the latest version number, and increments it by 1 to create a new version. It then updates the <code class="language-plaintext highlighter-rouge">version.txt</code> file and runs some git commands to commit the new version.</p>

<h2 id="step-2-creating-a-python-package">Step 2: Creating a Python Package</h2>

<p>To turn our Python script into a reusable tool, we need to create a Python package. To start, we create a directory named <code class="language-plaintext highlighter-rouge">kangtools</code> under our project directory and place the <code class="language-plaintext highlighter-rouge">version_control.py</code> file into this directory.</p>

<p>We also need to create a <code class="language-plaintext highlighter-rouge">__init__.py</code> file, which exports the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file as the API of our package.</p>

<p>Finally, we need to create a <code class="language-plaintext highlighter-rouge">setup.py</code> file, which describes our package and its metadata like name, version, author, etc. In the <code class="language-plaintext highlighter-rouge">setup.py</code> file, we also define a command-line interface that allows us to run the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file directly from the command line.</p>

<h2 id="step-3-installing-and-using-our-tool">Step 3: Installing and Using Our Tool</h2>

<p>We can install our tool using the <code class="language-plaintext highlighter-rouge">pip</code> command, just like installing any other Python package. Once installed, we can directly run the <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> command from the command line to use our tool. This command will prompt us to input a commit message, then generate a new version number and commit it to our codebase.</p>

<h2 id="done">Done!</h2>

<p>Now, you know how to create your own version control tool using Python. This is just a start, and you can modify this tool as per your needs. For example, you could make the tool support more complex version number formats, or make it work with other version control systems.</p>

<h2 id="download-instructions">Download Instructions</h2>

<p>You can directly download our package on PyPi: https://pypi.org/project/kangtools/</p>

<p>Installation: <code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>Usage: <code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p><em>Note: Before using this tool, make sure your codebase has been initialized as a git repository and that you have set up your git username and email.</em></p>

<p>Enjoy!</p>

<p><em>Disclaimer: This article is for educational purposes only, for actual version control applications, tools such as Git are usually used.</em></p>

<h1 id="使用-python-创建自定义的版本控制工具">使用 Python 创建自定义的版本控制工具</h1>

<p>在进行软件开发时，版本控制是至关重要的。它允许我们跟踪代码的更改，理解每个更改发生的时间和原因，以及谁进行了更改。让我们来看看如何使用 Python 来创建我们自己的版本控制工具。</p>

<h2 id="步骤-1-创建-python-脚本">步骤 1: 创建 Python 脚本</h2>

<p>我们首先创建一个 Python 脚本 <code class="language-plaintext highlighter-rouge">version_control.py</code>，这个脚本将为我们的代码库生成新的版本号。这个脚本使用 Python 的 <code class="language-plaintext highlighter-rouge">os</code> 和 <code class="language-plaintext highlighter-rouge">re</code> 模块，并包含一个名为 <code class="language-plaintext highlighter-rouge">main</code> 的函数，用于执行版本控制。</p>

<p>这个函数首先检查一个名为 <code class="language-plaintext highlighter-rouge">version.txt</code> 的文件是否存在，如果不存在，就创建它并写入初始版本号 <code class="language-plaintext highlighter-rouge">V.0.1</code>。然后，这个函数读取 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件的内容，找到最新的版本号，并将其加 1 以生成新的版本号。然后，这个函数更新 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件，并执行一些 git 命令来提交新的版本。</p>

<h2 id="步骤-2-创建-python-包">步骤 2: 创建 Python 包</h2>

<p>为了将我们的 Python 脚本转化为一个可复用的工具，我们需要创建一个 Python 包。首先，我们需要在我们的项目目录下创建一个名为 <code class="language-plaintext highlighter-rouge">kangtools</code> 的目录，然后将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件放入这个目录中。</p>

<p>我们还需要创建一个 <code class="language-plaintext highlighter-rouge">__init__.py</code> 文件，这个文件将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数导出为这个包的 API。</p>

<p>最后，我们需要创建一个 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件，这个文件描述了我们的包以及它的元数据，如名称、版本、作者等。在 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件中，我们还定义了一个命令行接口，允许我们直接从命令行运行 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数。</p>

<h2 id="步骤-3-安装并使用我们的工具">步骤 3: 安装并使用我们的工具</h2>

<p>我们可以使用 <code class="language-plaintext highlighter-rouge">pip</code> 命令来安装我们的工具，就像安装其他 Python 包一样。安装完成后，我们可以直接在命令行中运行 <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> 命令来使用我们的工具。这个命令将提示我们输入一个提交消息，然后生成一个新的版本号，并将它提交到我们的代码库。</p>

<h2 id="完成">完成!</h2>

<p>现在，你已经了解了如何使用 Python 创建自己的版本控制工具。这只是开始，你可以根据自己的需要修改这个工具，例如，你可以让这个工具支持更复杂的版本号格式，或者让它与其他的版本控制系统一起工作。</p>

<h2 id="下载方式">下载方式</h2>

<p>你可以直接在 PyPi 上下载我们的包：https://pypi.org/project/kangtools/</p>

<p>安装方式：<code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>使用方式：<code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p>*注意：使用这个工具</p>

<p>前，请确保你的代码库已经初始化为 git 仓库，并且你已经配置好了 git 的用户名和邮箱。*</p>

<p>祝你使用愉快！</p>

<p><em>注：该文章仅用于教学目的，实际的版本控制应用场景通常会使用更成熟的工具，如 Git。</em></p>]]></content><author><name></name></author><category term="version" /><category term="python" /><category term="control" /><category term="version control" /><category term="py" /><summary type="html"><![CDATA[TEST 1]]></summary></entry><entry><title type="html">Title: Automating Blog Publication and Versioning with Python</title><link href="https:///williampolicy.github.io/blog/2023/Title-Automating-Blog-Publication-and-Versioning-with-Python/" rel="alternate" type="text/html" title="Title: Automating Blog Publication and Versioning with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Title:-Automating-Blog-Publication-and-Versioning-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Title-Automating-Blog-Publication-and-Versioning-with-Python/"><![CDATA[<p>#Title: Automating Blog Publication and Versioning with Python</p>

<p>In the hustle and bustle of daily work, we often gain insights and accumulate knowledge that we’d like to share with others or keep for future reference. This is where blogging becomes an essential tool for expressing our ideas, sharing our learning, and reflecting on our experiences. However, the process of drafting, formatting, and publishing a blog post, especially when we want to do it frequently, can be time-consuming. To streamline this process and allow for more efficient knowledge sharing, we have devised an automation solution using Python, which enables us to publish and version our blogs with a single command.</p>

<p>The tool we’ve created offers several key features:</p>

<ol>
  <li>
    <p><strong>Preprocessing of Blog Files</strong>: The script can transform a text file into a specific format that is ready for publication, including extracting categories from the text, generating YAML front matter, and adjusting the title format.</p>
  </li>
  <li>
    <p><strong>Git Commit</strong>: After the preprocessing is done, the script will automatically commit the new blog file to a Git repository. The commit message includes the new version number, a user-defined commit message, the username, and a timestamp.</p>
  </li>
  <li>
    <p><strong>Version Control</strong>: After each commit, the new version number and associated details are written into a text file, allowing for easy tracking of versions.</p>
  </li>
</ol>

<p>使用此工具，不仅可以使博客发布过程变得自动化，而且通过版本控制，也方便我们追踪每个版本的变化，非常实用。以下是此工具的使用流程：</p>

<ol>
  <li>首先，我们使用argparse处理命令行参数，包括输入的文件名和提交信息。</li>
  <li>然后，使用nltk对文本进行预处理，从而提取文章的类别。</li>
  <li>通过get_title函数获取文章的标题，并进行格式化处理。</li>
  <li>create_blog_post函数则创建了新的博客文件，其中包含YAML前置内容和原始的文章内容。</li>
  <li>commit_version_to_git函数处理Git提交和版本控制。它首先读取版本文件，获取当前的版本号，然后进行版本号的递增，并进行Git的add、commit和push操作。最后，更新版本文件。</li>
</ol>

<p>总的来说，通过这个Python脚本，我们可以用一行命令就完成博客的预处理，Git提交以及版本控制，极大地提高了工作效率。不仅如此，它也为我们提供了一种方便的方式，快速分享和记录我们的知识和经验。</p>]]></content><author><name></name></author><category term="commit" /><category term="git" /><category term="blog" /><category term="version" /><category term="file" /><summary type="html"><![CDATA[#Title: Automating Blog Publication and Versioning with Python]]></summary></entry><entry><title type="html">i would like to make a blog anywhere</title><link href="https:///williampolicy.github.io/blog/2023/i-would-like-to-make-a-blog-anywhere/" rel="alternate" type="text/html" title="i would like to make a blog anywhere" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/i-would-like-to-make-a-blog-anywhere</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/i-would-like-to-make-a-blog-anywhere/"><![CDATA[<h1 id="i-would-like-to-make-a-blog-anywhere">i would like to make a blog anywhere</h1>

<p>i would like to make a blog anywhere</p>]]></content><author><name></name></author><category term="anywhere" /><category term="blog" /><category term="blog anywhere" /><category term="like" /><category term="like make" /><summary type="html"><![CDATA[i would like to make a blog anywhere]]></summary></entry><entry><title type="html">it works i want to go with you</title><link href="https:///williampolicy.github.io/blog/2023/it-works-i-want-to-go-with-you/" rel="alternate" type="text/html" title="it works i want to go with you" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/it-works-i-want-to-go-with-you</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/it-works-i-want-to-go-with-you/"><![CDATA[<h1 id="it-works-i-want-to-go-with-you">it works i want to go with you</h1>

<p>I know it hard .but i eolve. thank you for your help.</p>]]></content><author><name></name></author><category term="eolve" /><category term="eolve thank" /><category term="eolve thank help" /><category term="go" /><category term="go know" /><summary type="html"><![CDATA[it works i want to go with you]]></summary></entry><entry><title type="html">Mastering Gitignore in Xcode Projects.md</title><link href="https:///williampolicy.github.io/blog/2023/Mastering_Gitignore_in_Xcode_Projects/" rel="alternate" type="text/html" title="Mastering Gitignore in Xcode Projects.md" /><published>2023-06-20T00:00:00+00:00</published><updated>2023-06-20T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Mastering_Gitignore_in_Xcode_Projects</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Mastering_Gitignore_in_Xcode_Projects/"><![CDATA[<h2 id="mastering-gitignore-for-efficient-version-control">Mastering <code class="language-plaintext highlighter-rouge">.gitignore</code> for Efficient Version Control</h2>

<h3 id="introduction">Introduction</h3>

<p>A key component of any project using Git for version control, the <code class="language-plaintext highlighter-rouge">.gitignore</code> file allows developers to specify which files and directories should be excluded from Git tracking. This aids in keeping repositories clean, efficient, and free from unnecessary files like build outputs, system files, or secrets that should not be publicly accessible.</p>

<h3 id="understanding-the-gitignore-file">Understanding the <code class="language-plaintext highlighter-rouge">.gitignore</code> File</h3>

<p>The <code class="language-plaintext highlighter-rouge">.gitignore</code> file uses specific syntax to determine which files to ignore. Each line of the file specifies a pattern. If a file or directory matches this pattern, it is ignored by Git. Here are some example patterns and their meanings:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">*.log</code> - Ignores all files with the <code class="language-plaintext highlighter-rouge">.log</code> extension.</li>
  <li><code class="language-plaintext highlighter-rouge">/tmp</code> - Ignores the <code class="language-plaintext highlighter-rouge">tmp</code> directory located in the same directory as the <code class="language-plaintext highlighter-rouge">.gitignore</code> file.</li>
  <li><code class="language-plaintext highlighter-rouge">debug/</code> - Ignores the <code class="language-plaintext highlighter-rouge">debug</code> directory.</li>
  <li><code class="language-plaintext highlighter-rouge">debug/*.log</code> - Ignores all <code class="language-plaintext highlighter-rouge">.log</code> files in the <code class="language-plaintext highlighter-rouge">debug</code> directory.</li>
</ol>

<h3 id="common-challenges-with-gitignore">Common Challenges with <code class="language-plaintext highlighter-rouge">.gitignore</code></h3>

<p>One common misconception about the <code class="language-plaintext highlighter-rouge">.gitignore</code> file is that adding a file to <code class="language-plaintext highlighter-rouge">.gitignore</code> will cause it to be untracked if it’s already being tracked by Git. This is not true. To untrack a file that’s currently tracked by Git, you need to manually untrack it using the <code class="language-plaintext highlighter-rouge">git rm --cached &lt;file&gt;</code> command.</p>

<p>Another challenge arises when specifying the file paths. Git doesn’t recognize relative file paths in <code class="language-plaintext highlighter-rouge">.gitignore</code>. Always specify the path from the repository root.</p>

<h3 id="case-study-ignoring-secretsplist-in-an-xcode-project">Case Study: Ignoring <code class="language-plaintext highlighter-rouge">Secrets.plist</code> in an XCode Project</h3>

<p>Let’s look at a real-world example from our chat. We were trying to ignore a <code class="language-plaintext highlighter-rouge">Secrets.plist</code> file located in the <code class="language-plaintext highlighter-rouge">./GPT3_APP/GPT3_APP/</code> directory.</p>

<p>Firstly, the entry was added in <code class="language-plaintext highlighter-rouge">.gitignore</code> as follows:</p>

<pre><code class="language-gitignore"># .gitignore file
./GPT3_APP/GPT3_APP/Secrets.plist
</code></pre>

<p>But upon running <code class="language-plaintext highlighter-rouge">git add .</code> and <code class="language-plaintext highlighter-rouge">git commit</code>, we found that <code class="language-plaintext highlighter-rouge">Secrets.plist</code> was still being tracked.</p>

<p>The issue was with the use of relative file path. Git didn’t recognize <code class="language-plaintext highlighter-rouge">./</code> in the path. Upon changing the <code class="language-plaintext highlighter-rouge">.gitignore</code> file to:</p>

<pre><code class="language-gitignore"># .gitignore file
GPT3_APP/GPT3_APP/Secrets.plist
</code></pre>

<p>Git correctly ignored the <code class="language-plaintext highlighter-rouge">Secrets.plist</code> file.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Understanding and effectively using the <code class="language-plaintext highlighter-rouge">.gitignore</code> file is a critical skill for any developer using Git for version control. It helps keep your repositories clean and prevents unnecessary files from being tracked and shared. Remember, <code class="language-plaintext highlighter-rouge">.gitignore</code> does not retroactively untrack files, and always use file paths relative to the project root.</p>

<p>This case study offered a glimpse into a real-world application of <code class="language-plaintext highlighter-rouge">.gitignore</code>, highlighting how important understanding this simple, yet powerful tool is for effective version control.</p>

<p>The file name of the blog as per your request would be: <code class="language-plaintext highlighter-rouge">2023-06-20-Understanding_Xcode_ProjecStructure_A_Comparative_Analysis.md</code></p>]]></content><author><name></name></author><category term="tutorial" /><category term="iOS development" /><category term="Swift" /><category term="SwiftUI" /><summary type="html"><![CDATA[Mastering .gitignore for Efficient Version Control]]></summary></entry><entry><title type="html">Understanding Xcode Project Structure: A Comparative Analysis</title><link href="https:///williampolicy.github.io/blog/2023/Understanding_Xcode_ProjecStructure_A_Comparative_Analysis/" rel="alternate" type="text/html" title="Understanding Xcode Project Structure: A Comparative Analysis" /><published>2023-06-20T00:00:00+00:00</published><updated>2023-06-20T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Understanding_Xcode_ProjecStructure_A_Comparative_Analysis</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Understanding_Xcode_ProjecStructure_A_Comparative_Analysis/"><![CDATA[<h1 id="understanding-xcode-project-structure-a-comparative-analysis">Understanding Xcode Project Structure: A Comparative Analysis</h1>

<p>Understanding the structure of an Xcode project is a crucial aspect of iOS development. The project structure informs how the source code, resources, and configuration files are organized, which helps in maintaining the project and collaborating with other developers more effectively. In this post, we will compare two Xcode project structures to better understand their layout and organization.</p>

<h2 id="project-structure-of-a-basic-swiftui-app">Project Structure of a Basic SwiftUI App</h2>

<p>The first project we are analyzing is a simple “Hello World” SwiftUI application. Its structure is as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HelloWorld
├── HelloWorld.xcodeproj
├── HelloWorld
│   ├── ContentView.swift
│   ├── AppDelegate.swift
│   └── ...
└── ...
</code></pre></div></div>

<h2 id="project-structure-of-our-custom-app">Project Structure of Our Custom App</h2>

<p>Our custom application, named ‘kang001’, has a different structure:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kang001
├── kang001
│   ├── Assets.xcassets
│   ├── ContentView.swift
│   ├── Preview Content
│   └── kang001App.swift
├── kang001.xcodeproj
│   ├── project.pbxproj
│   ├── project.xcworkspace
│   └── xcuserdata
├── kang001Tests
│   └── kang001Tests.swift
└── kang001UITests
    ├── kang001UITests.swift
    └── kang001UITestsLaunchTests.swift
</code></pre></div></div>

<h2 id="comparative-analysis">Comparative Analysis</h2>

<p>By comparing these two structures, we notice some important differences and similarities:</p>

<ol>
  <li>
    <p><strong>Shared Components</strong>: Both projects have a <code class="language-plaintext highlighter-rouge">.xcodeproj</code> directory containing the project settings and configurations, and a <code class="language-plaintext highlighter-rouge">ContentView.swift</code> file which is the primary user interface file in SwiftUI.</p>
  </li>
  <li>
    <p><strong>Testing Suites</strong>: The ‘kang001’ project contains <code class="language-plaintext highlighter-rouge">kang001Tests</code> and <code class="language-plaintext highlighter-rouge">kang001UITests</code> directories for unit tests and UI tests respectively. These directories are not present in the ‘HelloWorld’ project.</p>
  </li>
  <li>
    <p><strong>Assets</strong>: The ‘kang001’ project includes an <code class="language-plaintext highlighter-rouge">Assets.xcassets</code> directory for storing images, colors, and other assets. The ‘HelloWorld’ project does not show this, but it’s likely present in the ellipsis (<code class="language-plaintext highlighter-rouge">...</code>).</p>
  </li>
  <li>
    <p><strong>SwiftUI Life Cycle</strong>: In the ‘kang001’ project, we see a <code class="language-plaintext highlighter-rouge">kang001App.swift</code> file, which represents the entry point of the app using the new SwiftUI App life cycle introduced in iOS 14. The ‘HelloWorld’ project mentions an <code class="language-plaintext highlighter-rouge">AppDelegate.swift</code> file, indicating the use of the UIKit App life cycle.</p>
  </li>
</ol>

<p>This analysis helps us understand how different projects can have varying structures based on their requirements and the iOS version they target. Recognizing these variations and their implications will guide you in developing and managing your own iOS projects.</p>

<h1 id="理解xcode项目结构比较分析">理解Xcode项目结构：比较分析</h1>

<p>理解Xcode项目的结构是iOS开发的一个关键部分。项目结构决定了源代码、资源和配置文件的组织方式，这对于维护项目和与其他开发人员更有效地协作非常有帮助。在这篇文章中，我们将比较两种Xcode项目结构，以更好地理解它们的布局和组织方式。</p>

<h2 id="一个基础的swiftui应用程序的项目结构">一个基础的SwiftUI应用程序的项目结构</h2>

<p>我们首先分析的是一个简单的 “Hello World” SwiftUI应用程序。其结构如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HelloWorld
├── HelloWorld.xcodeproj
├── HelloWorld
│   ├── ContentView.swift
│   ├── AppDelegate.swift
│   └── ...
└── ...
</code></pre></div></div>

<h2 id="我们自定义应用的项目结构">我们自定义应用的项目结构</h2>

<p>我们自定义的应用，名为’kang001’，具有不同的结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kang001
├── kang001
│   ├── Assets.xcassets
│   ├── ContentView.swift
│   ├── Preview Content
│   └── kang001App.swift
├── kang001.xcodeproj
│   ├── project.pbxproj
│   ├── project.xcworkspace
│   └── xcuserdata
├── kang001Tests
│   └── kang001Tests.swift
└── kang001UITests
    ├── kang001UITests.swift
    └── kang001UITestsLaunchTests.swift
</code></pre></div></div>

<h2 id="比较分析">比较分析</h2>

<p>通过比较这两种结构，我们可以注意到一些重要的相似之处和差异：</p>

<ol>
  <li>
    <p><strong>共享组件</strong>：两个项目都有一个<code class="language-plaintext highlighter-rouge">.xcodeproj</code>目录，其中包含项目的设置和配置，以及一个<code class="language-plaintext highlighter-rouge">ContentView.swift</code>文件，这是SwiftUI中的主要用户界面文件。</p>
  </li>
  <li>
    <p><strong>测试套件</strong>：’kang001’项目包含<code class="language-plaintext highlighter-rouge">kang001Tests</code>和<code class="language-plaintext highlighter-rouge">kang001UITests</code>目录，分别用于单元测试和UI测试。这些目录在’HelloWorld’项目中并不存在。</p>
  </li>
  <li>
    <p><strong>资源</strong>：’kang001’项目包含一个<code class="language-plaintext highlighter-rouge">Assets.xcassets</code>目录，用于存储图像、颜色和其他资源。’HelloWorld’项目并未显示此项，但它很可能在省略号(<code class="language-plaintext highlighter-rouge">...</code>)中存在。</p>
  </li>
  <li>
    <p><strong>SwiftUI生命周期</strong>：在’kang001’项目中，我们看到了一个<code class="language-plaintext highlighter-rouge">kang001App.swift</code>文件，这代表了使用在iOS 14中引入的新的SwiftUI App生命周期的应用入口。’HelloWorld’项目中提到了一个<code class="language-plaintext highlighter-rouge">AppDelegate.swift</code>文件，表示使用的是UIKit App生命周期。</p>
  </li>
</ol>

<p>这种分析帮助我们理解基于不同的需求和目标iOS版本的不同项目可能具有不同的结构。识别这些变化及其影响将在你开发和管理</p>

<p>自己的iOS项目时起着指导作用。</p>]]></content><author><name></name></author><category term="tutorial" /><category term="iOS development" /><category term="Swift" /><category term="SwiftUI" /><summary type="html"><![CDATA[Understanding Xcode Project Structure: A Comparative Analysis]]></summary></entry></feed>