<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https:///williampolicy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https:///williampolicy.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-27T20:37:45+00:00</updated><id>https:///williampolicy.github.io/feed.xml</id><title type="html">blank</title><subtitle>I would want to make a set [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/" rel="alternate" type="text/html" title="" /><published>2023-06-27T20:37:45+00:00</published><updated>2023-06-27T20:37:45+00:00</updated><id>https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/2023-06-19-Integrating-GPT3-into-iOS-Apps/"><![CDATA[<p>Today we explored how to integrate OpenAI’s GPT-3 into an iOS application using Swift. This process mainly involves setting up API requests, handling response data, and testing in a simulator. In this process, we also used Git for version control and error tracking.</p>

<h2 id="setting-up-api-requests">Setting Up API Requests</h2>
<p>We first created a function in Swift to set up the API request. This function takes an input prompt and sends it to the OpenAI API to generate GPT-3 output. We used the <code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code> function to send the request and <code class="language-plaintext highlighter-rouge">JSONSerialization</code> to convert the returned data into a JSON format we can handle.</p>

<h2 id="handling-api-responses">Handling API Responses</h2>
<p>When handling the API response, we focused on the <code class="language-plaintext highlighter-rouge">choices</code> field, which contains the text generated by GPT-3. We took the first choice from this field and returned it as the result of the function.</p>

<h2 id="testing-in-simulator">Testing in Simulator</h2>
<p>Next, we tested in the iOS simulator. We used the command-line tool <code class="language-plaintext highlighter-rouge">xcrun simctl</code> to manage the simulator and the <code class="language-plaintext highlighter-rouge">xcrun simctl launch</code> command to launch our application. When the application runs in the simulator, we can see all the output of the print() statements in the console, including any error messages, which is very useful for debugging.</p>

<h2 id="using-git-for-version-control-and-error-tracking">Using Git for Version Control and Error Tracking</h2>
<p>When we encountered errors, we used Git for error tracking.</p>

<hr />

<p><strong>layout:</strong> post</p>

<p><strong>title:</strong> “集成GPT-3到iOS应用中：使用Swift进行OpenAI API调用”</p>

<p><strong>date:</strong> 2023-06-19</p>

<p><strong>categories:</strong> [OpenAI, GPT-3, iOS, Swift, App Development]</p>

<hr />

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<h2 id="创建api请求">创建API请求</h2>
<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用<code class="language-plaintext highlighter-rouge">URLSession.shared.dataTask(with:completionHandler:)</code>函数发送请求，并使用<code class="language-plaintext highlighter-rouge">JSONSerialization</code>将返回的数据转换为我们可以处理的JSON格式。</p>

<h2 id="处理api响应">处理API响应</h2>
<p>在处理API响应时，我们主要关注的是<code class="language-plaintext highlighter-rouge">choices</code>字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<h2 id="在模拟器中进行测试">在模拟器中进行测试</h2>
<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具<code class="language-plaintext highlighter-rouge">xcrun simctl</code>来管理模拟器，并使用<code class="language-plaintext highlighter-rouge">xcrun simctl launch</code>命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>今天我们探索了如何使用Swift集成OpenAI的GPT-3到iOS应用中。这个过程主要分为几个步骤，包括设置API请求，处理响应数据，以及在模拟器中进行测试。在这个过程中，我们还使用了Git来进行版本控制和错误跟踪。</p>

<p>我们首先使用Swift创建了一个函数来构建API请求。这个函数需要接受一个输入提示，然后将它发送到OpenAI的API，从而生成GPT-3的输出。我们使用URLSession.shared.dataTask(with:completionHandler:)函数发送请求，并使用JSONSerialization将返回的数据转换为我们可以处理的JSON格式。</p>

<p>在处理API响应时，我们主要关注的是choices字段，这个字段包含了GPT-3生成的文本。我们从这个字段中获取第一条选择，并将其作为函数的结果返回。</p>

<p>然后，我们在iOS模拟器中进行测试。我们使用了命令行工具xcrun simctl来管理模拟器，并使用xcrun simctl launch命令来启动我们的应用。在模拟器运行应用时，我们可以在控制台看到所有的print()语句输出，包括任何错误信息，这对于调试非常有用。</p>

<p>当我们遇到错误时，我们使用Git进行错误跟踪。我们首先使用git diff查看自上次提交以来我们做了哪些改动，然后使用git log查看提交历史，找出可能导致错误的提交。一旦找到错误，我们就可以使用git revert来撤销这个提交，然后再进行修复。</p>

<p>当我们的应用正常运行并能够产生期望的输出时，我们使用Git来保存这个版本。我们首先使用git add .将所有改动添加到暂存区，然后使用git commit -m提交这些改动，并添加一个描述性的消息。最后，我们使用git tag添加一个标签来标记这个版本，然后使用git push将这个标签推送到远程仓库。</p>

<p>今天的工作中，我们学到了很多关于如何集成OpenAI的GPT-3到iOS应用中，如何在模拟器中进行测试，以及如何使用Git进行版本控制和错误跟踪的知识。我们还通过实际的操作，熟悉了这些工具和技术的应用。希望这个经验对你的工作也有所帮</p>]]></content><author><name></name></author></entry><entry><title type="html"></title><link href="https:///williampolicy.github.io/blog/2023/" rel="alternate" type="text/html" title="" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/"><![CDATA[<h1 id="dirac-delta-function-and-approaching-truth">Dirac Delta Function and Approaching Truth</h1>

<h2 id="dirac-delta-function-a-tool-for-first-order-approximation">Dirac Delta Function: A Tool for First-Order Approximation</h2>

<p>The Dirac delta function is a crucial tool we utilize to approach complex systems. This function is particularly significant in the microscopic world, as it can depict sudden changes and transitions, acting as a connector between continuous and discrete sampling. The Dirac delta function bridges high-dimensional and low-dimensional spaces, revealing the relationships between the two. Thus, we can perceive discrete phenomena, which are frequently observed during the quantization process.</p>

<p>Although the Dirac delta function is an idealized tool, its properties of infinity and infinitesimal provide a new perspective for understanding phenomena. However, this first-order approximation may face difficulties in practical applications and numerical simulations.</p>

<h2 id="second-order-approximation-adapting-to-reality">Second-Order Approximation: Adapting to Reality</h2>

<p>Faced with the challenges of practical applications, we often need to adopt more practical second-order approximation methods, such as using Gaussian functions or Cauchy distribution functions to simulate the Dirac delta function. While this practice may sacrifice some degree of truth purity, it enables more convenient numerical simulation and theoretical analysis.</p>

<p>This second-order approximation method allows us to see the underlying structure more clearly and facilitates practical operations. With specific numerical simulations and functions, we can quantify infinity and infinitesimal, and carry out grading and hierarchical treatment of them, which is of vital significance for our understanding and simulation of real-world problems.</p>

<h2 id="grading-issue-of-infinity-and-infinitesimal">Grading Issue of Infinity and Infinitesimal</h2>

<p>In this process, we noticed that infinity and infinitesimal are not simple concepts. Infinity and infinitesimal actually exist at different levels, which is determined by comparing their behaviors. This treatment allows us to grade and hierarchically process infinity and infinitesimal.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Whether it’s the first-order approximation of the Dirac delta function or the more practical second-order approximation method, we are approaching the complex, profound real world in our own ways. In the pursuit of scientific truth, we often need to strike a balance between theoretical rigor and practicality. That’s the essence of science.</p>

<p>#狄拉克函数与逼近真相</p>

<p>##狄拉克函数：一级逼近的工具
狄拉克函数是我们用来逼近复杂系统的一个重要工具。这个函数在微观世界中尤其重要，因为它可以描述突变和跃变，是连续和离散采样的连通器。狄拉克函数把高维度空间和低维度空间连通起来，揭示了这两个空间之间的关系。因此，我们可以看到离散的现象，这是我们在量子化过程中经常会看到的。</p>

<p>尽管狄拉克函数是一种理想化的工具，其无穷大和无穷小的性质为我们理解现象提供了新的视角，但在实际的应用和数值模拟中，这种一级逼近可能存在困难。</p>

<p>##二级逼近：适应现实的方法
面对实际应用的挑战，我们往往需要采用更加实用的二级逼近方法，例如使用高斯函数或Cauchy分布函数等来模拟狄拉克函数。这种做法虽然会牺牲一部分真相纯度，但却能使我们能够更方便地进行数值模拟和理论分析。</p>

<p>这种二级逼近方法让我们可以更加清楚地看到背后的结构，也方便我们进行实际操作。通过具体的数值模拟和函数，我们能够量化无穷大和无穷小，对它们进行分级和层次化的处理，这对我们理解和模拟现实问题有重要的意义。</p>

<p>##无穷大和无穷小的分级问题
在这个过程中，我们注意到无穷大和无穷小并非简单的概念。无穷大和无穷小实际上存在不同的级别，这是通过比较它们的行为来确定的。这样的处理方式，使得我们能够对无穷大和无穷小进行分级和分层次的处理。</p>

<p>##总结
无论是狄拉克函数的一级逼近，还是更实用的二级逼近方法，我们都在用自己的方式去逼近这个复杂、深奥的真实世界。在追求科学真相的过程中，我们经常需要在理论的严谨性和实用性之间做出权衡，这就是科学的本质。</p>]]></content><author><name></name></author><category term="function" /><category term="approximation" /><category term="delta" /><category term="delta function" /><category term="dirac" /><summary type="html"><![CDATA[Dirac Delta Function and Approaching Truth]]></summary></entry><entry><title type="html">Designing a Comprehensive Database for Dairy Products Sales Analysis</title><link href="https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis/" rel="alternate" type="text/html" title="Designing a Comprehensive Database for Dairy Products Sales Analysis" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Designing-a-Comprehensive-Database-for-Dairy-Products-Sales-Analysis/"><![CDATA[<p>#Designing a Comprehensive Database for Dairy Products Sales Analysis</p>

<h2 id="background">Background</h2>

<p>The dairy industry is a complex sector, and having a proper database design is crucial for understanding sales patterns, supply chain management, and consumer behavior. This blog post aims to present a comprehensive design for a dairy products sales database that takes into account various factors influencing the industry, including consumption patterns of families, detailed dairy product information, supplier data, discount events, holidays, and extreme weather conditions.</p>

<h2 id="requirements">Requirements</h2>

<p>The objective was to design a database for a hypothetical dairy company, aiming to assist in understanding sales trends, consumer behaviors, and supply chain dynamics. The database needed to be capable of answering critical questions like:</p>

<ul>
  <li>How do family consumption patterns change during holidays or extreme weather conditions?</li>
  <li>What are the sales trends for different dairy products?</li>
  <li>How do supplier flexibility and discount events impact sales and inventory?</li>
  <li>How does the timing of holidays influence sales?</li>
</ul>

<h2 id="database-design">Database Design</h2>

<p>To answer these questions, we conceptualized a relational database model with six primary tables and two summary tables.</p>

<h3 id="primary-tables">Primary Tables</h3>

<p><strong>T1_Family_Consumption</strong>: Each row represents a unique dairy product purchased by a specific family on a certain date, and fields include Family_ID, Product_ID, Date, Price_at_Purchase, Quantity, Is_Holiday, Is_Extreme_Weather, and Is_Discounted.</p>

<p><strong>T2_Dairy_Products</strong>: Each row represents daily information about a dairy product, and fields include Product_ID, Date, Price, Inventory, and Sales.</p>

<p><strong>T3_Suppliers</strong>: Each row represents supplier information for a specific dairy product, and fields include Supplier_ID, Product_ID, Supply_Price, and Flexibility.</p>

<p><strong>T4_Discounts</strong>: Each row signifies whether a specific product has a discount during a specific time period, and fields include Discount_ID, Product_ID, Start_Date, End_Date, and Discount_Rate.</p>

<p><strong>T5_Holidays</strong>: Each row denotes whether a particular date is a holiday, and fields include Date and Is_Holiday.</p>

<p><strong>T6_Extreme_Weather</strong>: Each row indicates whether there’s extreme weather on a specific date, and fields include Date and Is_Extreme.</p>

<h3 id="summary-tables">Summary Tables</h3>

<p><strong>T1S_Transactions_Summary</strong>: Each row represents aggregate information about a transaction, and fields include Transaction_ID, Date, Family_ID, Total_Quantity, and Total_Price.</p>

<p><strong>T4S_Discount_Events_Summary</strong>: Each row signifies overall information about a discount event, and fields include Discount_ID, Start_Date, End_Date, and Total_Products_Discounted.</p>

<h2 id="relationships">Relationships</h2>

<p>The primary tables are interconnected through specific fields such as Family_ID, Product_ID, Date, Transaction_ID, and Discount_ID. These connections allow for a comprehensive picture of the dairy sales cycle. The summary tables link to the primary tables through the Transaction_ID and Discount_ID fields, enabling an aggregated view of transaction and discount event details.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This database design offers a comprehensive approach to understand the sales dynamics in the dairy industry. By amalgamating various factors influencing sales, this design provides valuable insights that can assist in decision-making for the dairy company.</p>

<p>我将在下一次回应中将此博客翻译成中文。</p>]]></content><author><name></name></author><category term="id" /><category term="dairy" /><category term="date" /><category term="discount" /><category term="sales" /><summary type="html"><![CDATA[#Designing a Comprehensive Database for Dairy Products Sales Analysis]]></summary></entry><entry><title type="html">Dirac Delta Function and Approaching Truth</title><link href="https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth/" rel="alternate" type="text/html" title="Dirac Delta Function and Approaching Truth" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Dirac-Delta-Function-and-Approaching-Truth/"><![CDATA[<h1 id="dirac-delta-function-and-approaching-truth">Dirac Delta Function and Approaching Truth</h1>

<h2 id="dirac-delta-function-a-tool-for-first-order-approximation">Dirac Delta Function: A Tool for First-Order Approximation</h2>

<p>The Dirac delta function is a crucial tool we utilize to approach complex systems. This function is particularly significant in the microscopic world, as it can depict sudden changes and transitions, acting as a connector between continuous and discrete sampling. The Dirac delta function bridges high-dimensional and low-dimensional spaces, revealing the relationships between the two. Thus, we can perceive discrete phenomena, which are frequently observed during the quantization process.</p>

<p>Although the Dirac delta function is an idealized tool, its properties of infinity and infinitesimal provide a new perspective for understanding phenomena. However, this first-order approximation may face difficulties in practical applications and numerical simulations.</p>

<h2 id="second-order-approximation-adapting-to-reality">Second-Order Approximation: Adapting to Reality</h2>

<p>Faced with the challenges of practical applications, we often need to adopt more practical second-order approximation methods, such as using Gaussian functions or Cauchy distribution functions to simulate the Dirac delta function. While this practice may sacrifice some degree of truth purity, it enables more convenient numerical simulation and theoretical analysis.</p>

<p>This second-order approximation method allows us to see the underlying structure more clearly and facilitates practical operations. With specific numerical simulations and functions, we can quantify infinity and infinitesimal, and carry out grading and hierarchical treatment of them, which is of vital significance for our understanding and simulation of real-world problems.</p>

<h2 id="grading-issue-of-infinity-and-infinitesimal">Grading Issue of Infinity and Infinitesimal</h2>

<p>In this process, we noticed that infinity and infinitesimal are not simple concepts. Infinity and infinitesimal actually exist at different levels, which is determined by comparing their behaviors. This treatment allows us to grade and hierarchically process infinity and infinitesimal.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Whether it’s the first-order approximation of the Dirac delta function or the more practical second-order approximation method, we are approaching the complex, profound real world in our own ways. In the pursuit of scientific truth, we often need to strike a balance between theoretical rigor and practicality. That’s the essence of science.</p>

<p>#狄拉克函数与逼近真相</p>

<p>##狄拉克函数：一级逼近的工具
狄拉克函数是我们用来逼近复杂系统的一个重要工具。这个函数在微观世界中尤其重要，因为它可以描述突变和跃变，是连续和离散采样的连通器。狄拉克函数把高维度空间和低维度空间连通起来，揭示了这两个空间之间的关系。因此，我们可以看到离散的现象，这是我们在量子化过程中经常会看到的。</p>

<p>尽管狄拉克函数是一种理想化的工具，其无穷大和无穷小的性质为我们理解现象提供了新的视角，但在实际的应用和数值模拟中，这种一级逼近可能存在困难。</p>

<p>##二级逼近：适应现实的方法
面对实际应用的挑战，我们往往需要采用更加实用的二级逼近方法，例如使用高斯函数或Cauchy分布函数等来模拟狄拉克函数。这种做法虽然会牺牲一部分真相纯度，但却能使我们能够更方便地进行数值模拟和理论分析。</p>

<p>这种二级逼近方法让我们可以更加清楚地看到背后的结构，也方便我们进行实际操作。通过具体的数值模拟和函数，我们能够量化无穷大和无穷小，对它们进行分级和层次化的处理，这对我们理解和模拟现实问题有重要的意义。</p>

<p>##无穷大和无穷小的分级问题
在这个过程中，我们注意到无穷大和无穷小并非简单的概念。无穷大和无穷小实际上存在不同的级别，这是通过比较它们的行为来确定的。这样的处理方式，使得我们能够对无穷大和无穷小进行分级和分层次的处理。</p>

<p>##总结
无论是狄拉克函数的一级逼近，还是更实用的二级逼近方法，我们都在用自己的方式去逼近这个复杂、深奥的真实世界。在追求科学真相的过程中，我们经常需要在理论的严谨性和实用性之间做出权衡，这就是科学的本质。</p>]]></content><author><name></name></author><category term="function" /><category term="approximation" /><category term="delta" /><category term="delta function" /><category term="dirac" /><summary type="html"><![CDATA[Dirac Delta Function and Approaching Truth]]></summary></entry><entry><title type="html">Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum</title><link href="https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy-A-Case-Study-on-Food-Attraction-Spectrum/" rel="alternate" type="text/html" title="Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy:-A-Case-Study-on-Food-Attraction-Spectrum</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Mathematical-Principles-of-Philosophy-A-Case-Study-on-Food-Attraction-Spectrum/"><![CDATA[<h1 id="mathematical-principles-of-philosophy-a-case-study-on-food-attraction-spectrum">Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum</h1>

<h2 id="1-background">1. Background</h2>

<p>In this case study, we delve into a model aimed at understanding and predicting people’s food selection behaviors. Different foods might carry different weights depending on their various attributes such as nutritional value, taste, and so on. The probability of a food item being selected could vary with factors such as environment, availability, and individual preferences. Specifically, we consider drugs as a special case where the probability of selection is expected to be very low under normal circumstances.</p>

<h2 id="2-purpose">2. Purpose</h2>

<p>Our goal is to devise a quantitative method that captures the aforementioned process and aids in predicting the type of food individuals might select under a given set of conditions. To achieve this, we multiply the weight of a food item by the probability of its selection, followed by normalization to derive the relative attraction of different food items. In this model, we pay special attention to the case of drugs to comprehend how their attraction might change under certain conditions (for instance, when exposure to drugs occurs).</p>

<h2 id="3-method">3. Method</h2>

<p>We first define the weight and probability density for each food item. We then employ the Hadamard product (the product of the weight and probability density) to compute the attraction contribution of each food item. All the attraction contributions are normalized to obtain the relative attractions of various food items. In the case of drugs, we use the Dirac function to describe its probability density, allowing us to capture the potential enormous attraction that drugs may invoke once exposed to individuals.</p>

<h2 id="4-mathematical-expression">4. Mathematical Expression</h2>

<p>For each food item i, its attraction A_i can be calculated via the following equation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A_i = (w_i * p_i) / Σ (w_j * p_j)
</code></pre></div></div>

<p>Here, w_i represents the weight of food i, and p_i denotes the probability density of food i. For drugs, we employ the Dirac function to depict its probability density.</p>

<p>For apples and tomatoes, we use a periodic function to describe their probability density.</p>

<h2 id="5-code">5. Code</h2>

<p>Here is a snippet of the core Python code that was used to simulate the model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Define the weights
</span><span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">Apple</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tomato</span><span class="sh">"</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="sh">"</span><span class="s">Drug</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>

<span class="c1"># Define the probability density functions
</span><span class="k">def</span> <span class="nf">apple_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tomato_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">drug_density</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">0.01</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Calculate the attraction
</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">attractions</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">weight</span> <span class="o">*</span> <span class="nf">density</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">weights</span><span class="p">.</span><span class="nf">keys</span><span class="p">(),</span> <span class="p">[</span><span class="n">apple_density</span><span class="p">,</span> <span class="n">tomato_density</span><span class="p">,</span> <span class="n">drug_density</span><span class="p">])}</span>

<span class="c1"># Plot the attraction spectrum
</span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attraction</span> <span class="ow">in</span> <span class="n">attractions</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">attraction</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="6-conclusion">6. Conclusion</h2>

<p>Our model successfully demonstrates how to calculate attractions by considering the weight and probability density of food under different environmental conditions, predicting the potential food selections of individuals. It also illustrates the possible change in attraction in the event of exposure to drugs, helping us understand the impact of drugs on people’s choices.</p>

<h2 id="7-tips">7. Tips</h2>

<ul>
  <li>Our discussion revolved around the use and understanding of the Dirac function. We learned that although the probability density of drugs is zero in general, under certain conditions (like exposure to drugs), its probability density could suddenly increase, invoking a significant attraction.</li>
  <li>We discussed the choice</li>
</ul>

<p>of probability density functions. In this model, we chose periodic functions to describe the probability density for apples and tomatoes, simulating the impact of seasonal variations in food supply on food choices.</p>
<ul>
  <li>We also pondered on the limitations of our model. This model is simplified, and the real situation could be more complicated. For instance, people’s food choices might be influenced by a multitude of factors such as personal preferences, cultural backgrounds, economic conditions, and these factors were not considered in our model.</li>
  <li>Our conversation also touched upon various concepts related to probability, probability density, the Dirac function, and quantum mechanics. For instance, we talked about how the Dirac delta function, often used in quantum mechanics, can be used here to represent a sudden change in probability density when certain conditions are met.
    <h1 id="食物吸引力谱的数学建模一项案例研究">食物吸引力谱的数学建模：一项案例研究</h1>
  </li>
</ul>

<h2 id="1-背景">1. 背景</h2>

<p>在这个案例研究中，我们深入探讨一个旨在理解和预测人们食物选择行为的模型。不同的食物可能因其各种属性（如营养价值，口感等）具有不同的权重。食物被选择的概率可能因环境，可得性以及个人偏好等因素而变化。特别地，我们将成瘾类食物或药物（例如毒品）视为一种特殊情况，期望在正常情况下选择的概率非常低。</p>

<h2 id="2-目的">2. 目的</h2>

<p>我们的目标是设计一种定量方法，捕捉上述过程并有助于预测在给定一组条件下个体可能选择哪种食物。为此，我们将食物的权重与其选择的概率相乘，然后进行归一化以得出不同食物的相对吸引力。在这个模型中，我们特别关注成瘾类食物或药物的情况，以理解其吸引力在某些条件下（例如，当暴露于这类物质时）可能如何改变。</p>

<h2 id="3-方法">3. 方法</h2>

<p>我们首先为每种食物定义权重和概率密度。然后，我们使用哈达玛积（权重和概率密度的积）计算每种食物的吸引力贡献。所有的吸引力贡献都进行归一化，以获得各种食物的相对吸引力。对于成瘾类食物或药物，我们使用狄拉克函数来描述其概率密度，从而捕捉到这类物质一旦暴露给个体可能引起的巨大吸引力。</p>

<h2 id="4-数学表达">4. 数学表达</h2>

<p>对于每种食物i，其吸引力A_i可以通过以下方程计算：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A_i = (w_i * p_i) / Σ (w_j * p_j)
</code></pre></div></div>

<p>这里，w_i代表食物i的权重，p_i表示食物i的概率密度。对于成瘾类食物或药物，我们使用狄拉克函数来描述其概率密度。</p>

<p>对于苹果和番茄，我们使用周期函数来描述它们的概率密度。</p>

<h2 id="5-代码">5. 代码</h2>

<p>这是用来模拟模型的核心Python代码的一部分：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># 定义权重
</span><span class="n">weights</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">Apple</span><span class="sh">"</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">"</span><span class="s">Tomato</span><span class="sh">"</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="sh">"</span><span class="s">Addictive Substance</span><span class="sh">"</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>

<span class="c1"># 定义概率密度函数
</span><span class="k">def</span> <span class="nf">apple_density</span><span class="p">(</span><span class="n">t</span>

<span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">tomato_density</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">addictive_substance_density</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="c1"># 这里省略了成瘾物质的概率密度函数的具体实现。
</span>    <span class="k">pass</span>
</code></pre></div></div>

<h2 id="6-结论">6. 结论</h2>

<p>通过这种方式，我们可以通过调整权重和概率密度来模拟各种环境和个体条件下食物的吸引力。我们的模型特别强调成瘾类食物或药物在某些条件下（如当个体被暴露在这类物质中时）的巨大吸引力。</p>

<h2 id="7-提示和注意事项">7. 提示和注意事项</h2>

<ul>
  <li>本模型的一个重要前提是，所有食物的权重和概率密度都是已知的，这在实际应用中可能并不总是成立。</li>
  <li>狄拉克函数用于描述成瘾类食物或药物的概率密度，这是一个理想化的表示。实际上，这类物质的吸引力可能因人而异，取决于个体的生理和心理状态。</li>
  <li>我们的讨论中提到了一些与量子力学相关的概念，比如狄拉克函数和概率密度。然而，这些只是为了提供一个对概念的直观理解，而并非指这个模型具有与量子力学类似的性质。</li>
  <li>尽管我们使用了周期函数来描述苹果和番茄的概率密度，但实际上食物的可得性可能会受到更复杂的因素的影响，比如气候变化，季节变化，农业实践等。</li>
  <li>最后，本模型只是对食物选择行为的一种简化表示，而在实际中，食物选择可能受到许多其他因素的影响，比如文化，社会经济状态，健康状况等。</li>
</ul>]]></content><author><name></name></author><category term="density" /><category term="probability" /><category term="food" /><category term="probability density" /><category term="attraction" /><summary type="html"><![CDATA[Mathematical Principles of Philosophy: A Case Study on Food Attraction Spectrum]]></summary></entry><entry><title type="html">Quantum State Analysis: A Conceptual Understanding and Computation</title><link href="https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis-A-Conceptual-Understanding-and-Computation/" rel="alternate" type="text/html" title="Quantum State Analysis: A Conceptual Understanding and Computation" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis:-A-Conceptual-Understanding-and-Computation</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Quantum-State-Analysis-A-Conceptual-Understanding-and-Computation/"><![CDATA[<h1 id="quantum-state-analysis-a-conceptual-understanding-and-computation">Quantum State Analysis: A Conceptual Understanding and Computation</h1>

<h2 id="background">Background</h2>

<p>The concept of weight and probability density spectra can be generalized to various scientific domains, including quantum physics. This approach can facilitate a comprehensive understanding and analysis of complex systems. In the realm of quantum physics, the probability amplitude of a quantum state can be perceived as a form of “weight,” and its modulus squared (probability density) can be analyzed in tandem with this weight to draw meaningful conclusions about the system.</p>

<h2 id="concepts">Concepts</h2>

<p>In quantum physics, the state of a quantum system is often represented by a wave function, a mathematical description that provides information about the probability amplitude of finding the system in different states. These amplitude coefficients can be perceived as the “weight” of each state. The modulus squared of these amplitude coefficients gives us the “probability density” of finding the system in that specific state.</p>

<p>When the “weights” (probability amplitudes) and “probability densities” (modulus squared of amplitudes) are multiplied, we get a spectrum representing the contribution of each quantum state to the overall quantum system. This can be used to compute various expectation values, providing vital information about the behavior of the system.</p>

<h2 id="mathematical-description">Mathematical Description</h2>

<table>
  <tbody>
    <tr>
      <td>Let’s denote the probability amplitude (weight) for each state as $A = [a_1, a_2, …, a_n]$, where $a_i$ is the amplitude of the $i^{th}$ state. The probability density of each state, given by the modulus squared of the amplitude, is then $P = [</td>
      <td>a_1</td>
      <td>^2,</td>
      <td>a_2</td>
      <td>^2, …,</td>
      <td>a_n</td>
      <td>^2]$.</td>
    </tr>
  </tbody>
</table>

<p>The contribution of each state to the overall system, which we’ll refer to as the “quantum contribution spectrum”, $Q$, is then the Hadamard product of the weight and probability density spectra:</p>

<table>
  <tbody>
    <tr>
      <td>$Q = A \circ P = [a_1 \cdot</td>
      <td>a_1</td>
      <td>^2, a_2 \cdot</td>
      <td>a_2</td>
      <td>^2, …, a_n \cdot</td>
      <td>a_n</td>
      <td>^2]$</td>
    </tr>
  </tbody>
</table>

<p>Each component $q_i$ of the quantum contribution spectrum $Q$ then represents the contribution of the $i^{th}$ quantum state to the overall quantum system.</p>

<h2 id="example">Example</h2>

<p>In Python, this can be computed quite simply using the <code class="language-plaintext highlighter-rouge">numpy</code> library:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># example amplitudes for three quantum states
</span><span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">0.2j</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">])</span>

<span class="c1"># compute the probability densities
</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># compute the quantum contribution spectrum
</span><span class="n">contribution_spectrum</span> <span class="o">=</span> <span class="n">amplitudes</span> <span class="o">*</span> <span class="n">probabilities</span>
<span class="nf">print</span><span class="p">(</span><span class="n">contribution_spectrum</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>The quantum contribution spectrum provides an effective way to evaluate the contribution of individual quantum states to the overall quantum system. This concept, akin to the food consumption spectrum, allows us to incorporate both the significance and likelihood of different states to gain a comprehensive understanding of the quantum system.</p>

<h1 id="量子态分析概念理解与计算">量子态分析：概念理解与计算</h1>

<h2 id="背景">背景</h2>

<p>权重和概率密度谱的概念可以推广到包括量子物理学在内的各种科学领域。这种方法有助于全面理解和分析复杂的系统。在量子物理领域，量子态的概率振幅可以被视为一种“权重”，其模方（概率密度）可以与这个权重一起分析，以得出关于系统的有意义的结论。</p>

<h2 id="概念">概念</h2>

<p>在量子物理中，量子系统的状态通常由一个波函数表示，这是一个数学描述，提供了关于在不同状态下发现系统的概率振幅的信息。这些振幅系数可以被视为每个状态的”权重”。这些振幅系数的模方给出了在特定状态下找到系统的“概率密度”。</p>

<p>当”权重”（概率振幅）和”概率密度”（振幅模方）相乘时，我们得到一个表示每个量子态对整个量子系统贡献的谱。这可以用来计算各种期望值，提供关于系统行为的重要信息。</p>

<h2 id="数学描述">数学描述</h2>

<table>
  <tbody>
    <tr>
      <td>让我们把每个状态的概率振幅（权重）表示为 $A = [a_1, a_2, …, a_n]$，其中 $a_i$ 是第 $i$ 个状态的振幅。每个状态的概率密度，由振幅的模方给出，那么就是 $P = [</td>
      <td>a_1</td>
      <td>^2,</td>
      <td>a_2</td>
      <td>^2, …,</td>
      <td>a_n</td>
      <td>^2]$。</td>
    </tr>
  </tbody>
</table>

<p>每个状态对整个系统的贡献，我们将其称为”量子贡献谱”，$Q$，是权重谱和概率密度谱的哈达玛积：</p>

<table>
  <tbody>
    <tr>
      <td>$Q = A \circ P = [a_1 \cdot</td>
      <td>a_1</td>
      <td>^2, a_2 \cdot</td>
      <td>a_2</td>
      <td>^2, …, a_n \cdot</td>
      <td>a_n</td>
      <td>^2]$</td>
    </tr>
  </tbody>
</table>

<p>量子贡献谱 $Q$ 的每个组成部分 $q_i$ 都表示第 $i$ 个量子态对整个量子系统的贡献。</p>

<h2 id="例子">例子</h2>

<p>在 Python 中，这可以使用 <code class="language-plaintext highlighter-rouge">numpy</code> 库简单地计算：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># 三个量子态的例子振幅
</span><span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">0.3</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">+</span><span class="mf">0.2j</span><span class="p">,</span> <span class="mf">0.2</span><span class="o">+</span><span class="mf">0.1j</span><span class="p">])</span>

<span class="c1"># 计算概率密度
</span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># 计算量子贡献谱
</span><span class="n">contribution_spectrum</span> <span class="o">=</span> <span class="n">amplitudes</span> <span class="o">*</span> <span class="n">probabilities</span>
<span class="nf">print</span><span class="p">(</span><span class="n">contribution_spectrum</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="结论">结论</h2>

<p>量子贡献谱提供了一种有效的方法来评</p>

<p>估各个量子态对整个量子系统的贡献。这个概念类似于食物消费谱，让我们能够既考虑不同状态的重要性，也考虑它们发生的可能性，从而全面理解量子系统。</p>]]></content><author><name></name></author><category term="quantum" /><category term="contribution" /><category term="probability" /><category term="state" /><category term="spectrum" /><summary type="html"><![CDATA[Quantum State Analysis: A Conceptual Understanding and Computation]]></summary></entry><entry><title type="html">Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra</title><link href="https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns-Weights,-Probabilities,-and-Consumption-Spectra/" rel="alternate" type="text/html" title="Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra" /><published>2023-06-27T00:00:00+00:00</published><updated>2023-06-27T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns:-Weights,-Probabilities,-and-Consumption-Spectra</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Understanding-Food-Consumption-Patterns-Weights,-Probabilities,-and-Consumption-Spectra/"><![CDATA[<h1 id="understanding-food-consumption-patterns-weights-probabilities-and-consumption-spectra">Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra</h1>

<h2 id="1-background">1. Background</h2>

<p>In this study, we analyze food consumption patterns, more specifically, we delve into the weights and probabilities of food items, ultimately arriving at a food consumption spectrum. This problem can be considered both in discrete and continuous forms.</p>

<h2 id="2-methodology">2. Methodology</h2>

<p>Our method isn’t solely reliant on the perspective of neural networks. We can view the weights and probabilities of food items as independent variables, and then compute their Hadamard product (i.e., element-wise multiplication) to obtain the food consumption spectrum.</p>

<h2 id="3-mathematical-description">3. Mathematical Description</h2>

<p>In discrete form, we have n food items, each food item i has a weight <code class="language-plaintext highlighter-rouge">$w_i$</code> and a probability <code class="language-plaintext highlighter-rouge">$p_i$</code>. Hence, the food consumption spectrum <code class="language-plaintext highlighter-rouge">$c_i$</code> can be expressed as:</p>

<pre><code class="language-math">c_i = w_i \cdot p_i, \quad i=1, 2, ..., n.
</code></pre>

<p>In continuous form, we consider the weights and probabilities of food items as functions <code class="language-plaintext highlighter-rouge">$w(x)$</code> and <code class="language-plaintext highlighter-rouge">$p(x)$</code> defined over some interval, and then compute the food consumption spectrum <code class="language-plaintext highlighter-rouge">$c(x)$</code>:</p>

<pre><code class="language-math">c(x) = w(x) \cdot p(x), \quad x \in [a, b].
</code></pre>

<h2 id="4-example">4. Example</h2>

<p>For instance, we have three food items, with weights <code class="language-plaintext highlighter-rouge">$w_1 = 0.5, w_2 = 0.3, w_3 = 0.2$</code> and probabilities <code class="language-plaintext highlighter-rouge">$p_1 = 0.4, p_2 = 0.5, p_3 = 0.1$</code> respectively. Hence, the food consumption spectrum for these food items are <code class="language-plaintext highlighter-rouge">$c_1 = 0.5 \cdot 0.4 = 0.2, c_2 = 0.3 \cdot 0.5 = 0.15, c_3 = 0.2 \cdot 0.1 = 0.02$</code>.</p>

<p>We can compute these using the following Python code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>

<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="o">*</span><span class="n">pi</span> <span class="k">for</span> <span class="n">wi</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># prints: [0.2, 0.15, 0.02]
</span></code></pre></div></div>

<h2 id="5-conclusion">5. Conclusion</h2>

<p>Through the analysis of food weights and probabilities, we have arrived at a food consumption spectrum. Leveraging these independent variables, we’ve gained a fresh perspective on analyzing and understanding food consumption patterns.</p>

<hr />

<h1 id="理解食物消费模式权重概率和消费谱">理解食物消费模式：权重，概率和消费谱</h1>

<h2 id="1-背景">1. 背景</h2>

<p>在这个项目中，我们研究了食物消费模式，具体来说，我们分析了食物的权重和概率，最后得到了食物消费谱。这个问题可以通过离散和连续两种方式来考虑。</p>

<h2 id="2-方法">2. 方法</h2>

<p>我们的方法不仅限于神经网络的视角，我们可以将食物的权重和概率看作是独立的变量，然后通过计算它们的哈达玛积（Hadamard product，即逐元素相乘）来得到食物消费谱。</p>

<h2 id="3-数学描述">3. 数学描述</h2>

<p>在离散形式下，我们有n种食物，每种食物i有一个权重<code class="language-plaintext highlighter-rouge">$w_i$</code>和一个概率<code class="language-plaintext highlighter-rouge">$p_i$</code>，那么食物消费谱<code class="language-plaintext highlighter-rouge">$c_i$</code>可以表示为:</p>

<pre><code class="language-math">c_i = w_i \cdot p_i, \quad i=1, 2, ..., n.
</code></pre>

<p>在连续形式下，我们将食物的权重和概率看作是定义在某个区间上的函数<code class="language-plaintext highlighter-rouge">$w(x)$</code>和<code class="language-plaintext highlighter-rouge">$p(x)$</code>，然后计算得到食物消费谱<code class="language-plaintext highlighter-rouge">$c(x)$</code>：</p>

<pre><code class="language-math">c(x) = w(x) \cdot p(x), \quad x \in [a, b].
</code></pre>

<h2 id="4-案例">4. 案例</h2>

<p>例如，我们有三种食物，它们的权重分别为<code class="language-plaintext highlighter-rouge">$w_1 = 0.5, w_2 = 0.3, w_3 = 0.2$</code>，概率分别为<code class="language-plaintext highlighter-rouge">$p_1 = 0.4, p_2 = 0.5, p_3 = 0.1$</code>，那么这三种食物的消费谱分别为<code class="language-plaintext highlighter-rouge">$c_1 = 0.5 \cdot 0.4 = 0.2, c_2 = 0.3 \cdot 0.5 = 0.15, c_3 = 0.2 \cdot 0.1 = 0.02$</code>。</p>

<p>我们可以通过以下的Python代码来计算这个结果：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>

<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">wi</span><span class="o">*</span><span class="n">pi</span> <span class="k">for</span> <span class="n">wi</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># prints: [0.2, 0.15, 0.02]
</span></code></pre></div></div>

<h2 id="5-总结">5. 总结</h2>

<p>通过对食物权重和概率的分析，我们得到了食物消费谱。我们利用这些独立的变量，这为我们分析和理解食物消费模式提供了一个新的视角。</p>

<hr />]]></content><author><name></name></author><category term="c" /><category term="p" /><category term="w" /><category term="food" /><category term="x" /><summary type="html"><![CDATA[Understanding Food Consumption Patterns: Weights, Probabilities, and Consumption Spectra]]></summary></entry><entry><title type="html">Automating Blog Publication and Versioning with Python</title><link href="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/" rel="alternate" type="text/html" title="Automating Blog Publication and Versioning with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Automating-Blog-Publication-and-Versioning-with-Python/"><![CDATA[<h1 id="automating-blog-publication-and-versioning-with-python">Automating Blog Publication and Versioning with Python</h1>

<p>In the hustle and bustle of daily work, we often gain insights and accumulate knowledge that we’d like to share with others or keep for future reference. This is where blogging becomes an essential tool for expressing our ideas, sharing our learning, and reflecting on our experiences. However, the process of drafting, formatting, and publishing a blog post, especially when we want to do it frequently, can be time-consuming. To streamline this process and allow for more efficient knowledge sharing, we have devised an automation solution using Python, which enables us to publish and version our blogs with a single command.</p>

<p>The tool we’ve created offers several key features:</p>

<ol>
  <li>
    <p><strong>Preprocessing of Blog Files</strong>: The script can transform a text file into a specific format that is ready for publication, including extracting categories from the text, generating YAML front matter, and adjusting the title format.</p>
  </li>
  <li>
    <p><strong>Git Commit</strong>: After the preprocessing is done, the script will automatically commit the new blog file to a Git repository. The commit message includes the new version number, a user-defined commit message, the username, and a timestamp.</p>
  </li>
  <li>
    <p><strong>Version Control</strong>: After each commit, the new version number and associated details are written into a text file, allowing for easy tracking of versions.</p>
  </li>
</ol>

<p>使用此工具，不仅可以使博客发布过程变得自动化，而且通过版本控制，也方便我们追踪每个版本的变化，非常实用。以下是此工具的使用流程：</p>

<ol>
  <li>首先，我们使用argparse处理命令行参数，包括输入的文件名和提交信息。</li>
  <li>然后，使用nltk对文本进行预处理，从而提取文章的类别。</li>
  <li>通过get_title函数获取文章的标题，并进行格式化处理。</li>
  <li>create_blog_post函数则创建了新的博客文件，其中包含YAML前置内容和原始的文章内容。</li>
  <li>commit_version_to_git函数处理Git提交和版本控制。它首先读取版本文件，获取当前的版本号，然后进行版本号的递增，并进行Git的add、commit和push操作。最后，更新版本文件。</li>
</ol>

<p>总的来说，通过这个Python脚本，我们可以用一行命令就完成博客的预处理，Git提交以及版本控制，极大地提高了工作效率。不仅如此，它也为我们提供了一种方便的方式，快速分享和记录我们的知识和经验。</p>]]></content><author><name></name></author><category term="commit" /><category term="git" /><category term="blog" /><category term="version" /><category term="file" /><summary type="html"><![CDATA[Automating Blog Publication and Versioning with Python]]></summary></entry><entry><title type="html">Creating Custom Version Control Tool with Python</title><link href="https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python/" rel="alternate" type="text/html" title="Creating Custom Version Control Tool with Python" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Creating-Custom-Version-Control-Tool-with-Python/"><![CDATA[<h1 id="creating-custom-version-control-tool-with-python">Creating Custom Version Control Tool with Python</h1>

<p>new edition:</p>

<p>Version control is vital when it comes to software development. It allows us to track changes in our code, understand when and why each change was made, and who made the change. Let’s look at how to create our own version control tool using Python.</p>

<h2 id="step-1-creating-a-python-script">Step 1: Creating a Python Script</h2>

<p>Firstly, we create a Python script named <code class="language-plaintext highlighter-rouge">version_control.py</code>, which will generate new version numbers for our codebase. This script uses Python’s <code class="language-plaintext highlighter-rouge">os</code> and <code class="language-plaintext highlighter-rouge">re</code> modules and contains a function named <code class="language-plaintext highlighter-rouge">main</code> to execute version control.</p>

<p>This function first checks if a file named <code class="language-plaintext highlighter-rouge">version.txt</code> exists, and if not, it creates one and writes the initial version <code class="language-plaintext highlighter-rouge">V.0.1</code>. Next, the function reads the content of <code class="language-plaintext highlighter-rouge">version.txt</code>, finds the latest version number, and increments it by 1 to create a new version. It then updates the <code class="language-plaintext highlighter-rouge">version.txt</code> file and runs some git commands to commit the new version.</p>

<h2 id="step-2-creating-a-python-package">Step 2: Creating a Python Package</h2>

<p>To turn our Python script into a reusable tool, we need to create a Python package. To start, we create a directory named <code class="language-plaintext highlighter-rouge">kangtools</code> under our project directory and place the <code class="language-plaintext highlighter-rouge">version_control.py</code> file into this directory.</p>

<p>We also need to create a <code class="language-plaintext highlighter-rouge">__init__.py</code> file, which exports the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file as the API of our package.</p>

<p>Finally, we need to create a <code class="language-plaintext highlighter-rouge">setup.py</code> file, which describes our package and its metadata like name, version, author, etc. In the <code class="language-plaintext highlighter-rouge">setup.py</code> file, we also define a command-line interface that allows us to run the <code class="language-plaintext highlighter-rouge">main</code> function from the <code class="language-plaintext highlighter-rouge">version_control.py</code> file directly from the command line.</p>

<h2 id="step-3-installing-and-using-our-tool">Step 3: Installing and Using Our Tool</h2>

<p>We can install our tool using the <code class="language-plaintext highlighter-rouge">pip</code> command, just like installing any other Python package. Once installed, we can directly run the <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> command from the command line to use our tool. This command will prompt us to input a commit message, then generate a new version number and commit it to our codebase.</p>

<h2 id="done">Done!</h2>

<p>Now, you know how to create your own version control tool using Python. This is just a start, and you can modify this tool as per your needs. For example, you could make the tool support more complex version number formats, or make it work with other version control systems.</p>

<h2 id="download-instructions">Download Instructions</h2>

<p>You can directly download our package on PyPi: https://pypi.org/project/kangtools/</p>

<p>Installation: <code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>Usage: <code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p><em>Note: Before using this tool, make sure your codebase has been initialized as a git repository and that you have set up your git username and email.</em></p>

<p>Enjoy!</p>

<p><em>Disclaimer: This article is for educational purposes only, for actual version control applications, tools such as Git are usually used.</em></p>

<h1 id="使用-python-创建自定义的版本控制工具">使用 Python 创建自定义的版本控制工具</h1>

<p>在进行软件开发时，版本控制是至关重要的。它允许我们跟踪代码的更改，理解每个更改发生的时间和原因，以及谁进行了更改。让我们来看看如何使用 Python 来创建我们自己的版本控制工具。</p>

<h2 id="步骤-1-创建-python-脚本">步骤 1: 创建 Python 脚本</h2>

<p>我们首先创建一个 Python 脚本 <code class="language-plaintext highlighter-rouge">version_control.py</code>，这个脚本将为我们的代码库生成新的版本号。这个脚本使用 Python 的 <code class="language-plaintext highlighter-rouge">os</code> 和 <code class="language-plaintext highlighter-rouge">re</code> 模块，并包含一个名为 <code class="language-plaintext highlighter-rouge">main</code> 的函数，用于执行版本控制。</p>

<p>这个函数首先检查一个名为 <code class="language-plaintext highlighter-rouge">version.txt</code> 的文件是否存在，如果不存在，就创建它并写入初始版本号 <code class="language-plaintext highlighter-rouge">V.0.1</code>。然后，这个函数读取 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件的内容，找到最新的版本号，并将其加 1 以生成新的版本号。然后，这个函数更新 <code class="language-plaintext highlighter-rouge">version.txt</code> 文件，并执行一些 git 命令来提交新的版本。</p>

<h2 id="步骤-2-创建-python-包">步骤 2: 创建 Python 包</h2>

<p>为了将我们的 Python 脚本转化为一个可复用的工具，我们需要创建一个 Python 包。首先，我们需要在我们的项目目录下创建一个名为 <code class="language-plaintext highlighter-rouge">kangtools</code> 的目录，然后将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件放入这个目录中。</p>

<p>我们还需要创建一个 <code class="language-plaintext highlighter-rouge">__init__.py</code> 文件，这个文件将 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数导出为这个包的 API。</p>

<p>最后，我们需要创建一个 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件，这个文件描述了我们的包以及它的元数据，如名称、版本、作者等。在 <code class="language-plaintext highlighter-rouge">setup.py</code> 文件中，我们还定义了一个命令行接口，允许我们直接从命令行运行 <code class="language-plaintext highlighter-rouge">version_control.py</code> 文件中的 <code class="language-plaintext highlighter-rouge">main</code> 函数。</p>

<h2 id="步骤-3-安装并使用我们的工具">步骤 3: 安装并使用我们的工具</h2>

<p>我们可以使用 <code class="language-plaintext highlighter-rouge">pip</code> 命令来安装我们的工具，就像安装其他 Python 包一样。安装完成后，我们可以直接在命令行中运行 <code class="language-plaintext highlighter-rouge">kangtools_version_control</code> 命令来使用我们的工具。这个命令将提示我们输入一个提交消息，然后生成一个新的版本号，并将它提交到我们的代码库。</p>

<h2 id="完成">完成!</h2>

<p>现在，你已经了解了如何使用 Python 创建自己的版本控制工具。这只是开始，你可以根据自己的需要修改这个工具，例如，你可以让这个工具支持更复杂的版本号格式，或者让它与其他的版本控制系统一起工作。</p>

<h2 id="下载方式">下载方式</h2>

<p>你可以直接在 PyPi 上下载我们的包：https://pypi.org/project/kangtools/</p>

<p>安装方式：<code class="language-plaintext highlighter-rouge">pip install kangtools</code></p>

<p>使用方式：<code class="language-plaintext highlighter-rouge">kangtools_version_control</code></p>

<p>*注意：使用这个工具</p>

<p>前，请确保你的代码库已经初始化为 git 仓库，并且你已经配置好了 git 的用户名和邮箱。*</p>

<p>祝你使用愉快！</p>

<p><em>注：该文章仅用于教学目的，实际的版本控制应用场景通常会使用更成熟的工具，如 Git。</em></p>]]></content><author><name></name></author><category term="version" /><category term="python" /><category term="control" /><category term="version control" /><category term="py" /><summary type="html"><![CDATA[Creating Custom Version Control Tool with Python]]></summary></entry><entry><title type="html">Streamlining PyPi Package Release with Automation and Version Control</title><link href="https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control/" rel="alternate" type="text/html" title="Streamlining PyPi Package Release with Automation and Version Control" /><published>2023-06-26T00:00:00+00:00</published><updated>2023-06-26T00:00:00+00:00</updated><id>https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control</id><content type="html" xml:base="https:///williampolicy.github.io/blog/2023/Streamlining-PyPi-Package-Release-with-Automation-and-Version-Control/"><![CDATA[<h1 id="streamlining-pypi-package-release-with-automation-and-version-control">Streamlining PyPi Package Release with Automation and Version Control</h1>

<p>As developers, we often build packages that help others in our community solve complex problems. Sharing these packages on platforms like PyPi allows users worldwide to access, download, and benefit from our creations. However, managing the versioning, building, and releasing of a package can sometimes be a cumbersome process.</p>

<p>To enhance the efficiency and accuracy of this process, we have devised a Python-based solution that automates the lifecycle of a PyPi package. This solution focuses on three key stages: versioning, building, and releasing.</p>

<ol>
  <li>
    <p><strong>Versioning</strong>: The script automates the versioning process by maintaining a version.txt file. Each new version number is appended to this file, along with the timestamp, aiding in version tracking.</p>
  </li>
  <li>
    <p><strong>Building</strong>: The script leverages Python’s setuptools and wheel to build the package. The ‘setup.py’ file, which contains necessary metadata, is automatically updated with each version release.</p>
  </li>
  <li>
    <p><strong>Releasing</strong>: The script uses twine to upload the package to PyPi. Twine is a utility that enables you to publish Python packages over PyPi securely.</p>
  </li>
</ol>

<p>An additional feature of this automation solution is the inclusion of a command-line interface. Users can execute a single command that automates the entire lifecycle of the package.</p>

<p>Here’s an overview of the workflow:</p>

<ol>
  <li>The argparse module is used to handle command-line arguments, which includes the package name.</li>
  <li>The version number is automatically incremented and updated in the ‘setup.py’ file and the ‘version.txt’ file.</li>
  <li>The script then removes old distributions and builds new ones using setuptools and wheel.</li>
  <li>Finally, the newly built distribution is uploaded to PyPi using twine.</li>
</ol>

<p>In conclusion, this Python script significantly simplifies the management and release of PyPi packages. By automating version control, package building, and releasing, it not only saves time but also minimizes the chances of manual error. This solution is especially useful for developers who regularly maintain and release Python packages on PyPi.</p>]]></content><author><name></name></author><category term="package" /><category term="pypi" /><category term="version" /><category term="file" /><category term="packages" /><summary type="html"><![CDATA[Streamlining PyPi Package Release with Automation and Version Control]]></summary></entry></feed>